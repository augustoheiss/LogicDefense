<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Logic Defense: O Museu dos N√∫meros</title>
    <script src="https://www.youtube.com/iframe_api"></script>
    <style>
        body { 
            margin: 0; padding: 0; overflow: hidden; background-color: #050505; color: white; 
            font-family: 'Courier New', monospace; user-select: none; touch-action: none;
            width: 100vw; height: 100vh;
        }

        /* TEXTOS AMBIENTES DO MUSEU (Sussurros da Matem√°tica ao Fundo) - TUDO NA HORIZONTAL */
        .museum-text {
            position: absolute; color: rgba(0, 212, 255, 0.08); 
            font-family: 'Courier New', monospace; font-weight: bold; z-index: -200; 
            pointer-events: none; white-space: nowrap; text-shadow: 0 0 15px rgba(0,212,255,0.1);
        }
        
        /* Espalhando os vi√©ses ao redor do centro (800x600) */
        .mt-1 { top: 3%; left: 2%; font-size: 22px; }
        .mt-2 { top: 12%; left: 15%; font-size: 14px; color: rgba(0, 255, 0, 0.06); }
        .mt-3 { top: 4%; right: 3%; font-size: 20px; text-align: right; }
        .mt-4 { top: 15%; right: 10%; font-size: 16px; text-align: right; color: rgba(255, 235, 59, 0.06); }
        .mt-5 { top: 25%; left: 3%; font-size: 18px; }
        .mt-6 { top: 40%; left: 1%; font-size: 14px; color: rgba(255, 68, 68, 0.07); }
        .mt-7 { top: 30%; right: 2%; font-size: 19px; text-align: right; }
        .mt-8 { top: 45%; right: 5%; font-size: 15px; text-align: right; color: rgba(156, 39, 176, 0.07); }
        .mt-9 { bottom: 5%; left: 2%; font-size: 24px; }
        .mt-10 { bottom: 15%; left: 12%; font-size: 16px; }
        .mt-11 { bottom: 6%; right: 3%; font-size: 21px; text-align: right; }
        .mt-12 { bottom: 18%; right: 8%; font-size: 14px; text-align: right; color: rgba(0, 212, 255, 0.06); }
        .mt-13 { top: 60%; left: 2%; font-size: 17px; }
        .mt-14 { top: 75%; left: 8%; font-size: 13px; color: rgba(255, 255, 255, 0.05); }
        .mt-15 { top: 65%; right: 3%; font-size: 18px; text-align: right; }
        .mt-16 { top: 80%; right: 15%; font-size: 15px; text-align: right; }

        /* Oculta os textos do museu em telas pequenas (celulares verticais) para n√£o poluir por cima do Canvas */
        @media (max-width: 1100px) { .museum-text { display: none; } }
        
        #game-container { 
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%); 
            width: 800px; height: 600px; 
            border: 2px solid #444; border-radius: 10px;
            background-image: url('https://images.unsplash.com/photo-1462331940025-496dfbfc7564?auto=format&fit=crop&w=1000&q=80');
            background-size: cover; background-position: center;
            box-shadow: 0 0 40px rgba(0, 212, 255, 0.3); overflow: hidden;
            margin: 0; z-index: 10;
        }
        
        #game-container::before {
            content: ""; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 10, 0.6); z-index: 0; pointer-events: none; transition: background 1s;
        }
        #game-container.cinematic-mode::before { background: rgba(0, 0, 0, 0.95); }

        canvas { display: block; cursor: crosshair; position: absolute; top:0; left:0; width: 100%; height: 100%; z-index: 1; }
        
        #ui-layer { position: absolute; top: 10px; left: 10px; width: calc(100% - 20px); pointer-events: none; display: flex; flex-wrap: wrap; gap: 10px; transition: opacity 0.3s; align-items: center; z-index: 20;}
        
        .stat-box { 
            background: rgba(0,0,0,0.8); padding: 8px 12px; border: 1px solid #00ff00; color: #00ff00; 
            font-weight: bold; font-size: 14px; border-radius: 4px; box-shadow: 0 0 10px rgba(0,255,0,0.2);
            pointer-events: auto; cursor: help; position: relative;
        }
        .score-box { border-color: #fff; color: #fff; box-shadow: 0 0 10px rgba(255,255,255,0.2);}
        
        .tooltip-text {
            visibility: hidden; width: 280px; background-color: rgba(0,0,0,0.95); color: #fff; text-align: left;
            border-radius: 6px; padding: 10px; border: 1px solid #00d4ff; position: absolute; z-index: 100;
            top: 130%; left: 0; font-size: 12px; opacity: 0; transition: opacity 0.3s; box-shadow: 0 0 15px rgba(0,212,255,0.5);
            font-weight: normal; line-height: 1.4; pointer-events: none;
        }
        .stat-box:hover .tooltip-text, .stat-box:active .tooltip-text { visibility: visible; opacity: 1; }
        .tt-highlight { color: #ffeb3b; font-weight: bold; }

        .top-btn { pointer-events: auto; background: rgba(0,0,0,0.8); border: 2px solid #fff; color: white; padding: 8px 15px; font-weight: bold; cursor: pointer; border-radius: 4px; transition: 0.2s; }
        .top-btn:hover { transform: scale(1.05); }
        #speed-btn.active { background: #ff9800; color: black; border-color: #ff9800; box-shadow: 0 0 15px #ff9800; }
        #speed-btn.max { background: #f44336; color: white; border-color: #f44336; box-shadow: 0 0 15px #f44336; }
        #ai-btn.active { background: #00d4ff; color: black; border-color: #00d4ff; box-shadow: 0 0 15px #00d4ff; }
        #ghost-btn.active { background: #8a2be2; color: white; border-color: #8a2be2; box-shadow: 0 0 15px #8a2be2; }

        body.hide-ui #build-menu, body.hide-ui #next-wave-btn, body.hide-ui #math-tip-box, body.hide-ui .stat-box, body.hide-ui #speed-btn, body.hide-ui #ai-btn, body.hide-ui #fullscreen-btn {
            opacity: 0.15 !important; pointer-events: none !important;
        }
        body.ghost-active #build-menu { display: none !important; }
        body.ghost-active #ui-layer, body.ghost-active #math-tip-box { opacity: 0.15 !important; pointer-events: none !important; }

        #start-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.90); z-index: 200; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .buff-btn { margin: 10px; padding: 15px 30px; font-size: 22px; cursor: pointer; border: 2px solid white; background: rgba(0,0,0,0.6); color: white; font-family: inherit; transition: 0.2s; width: 320px; text-align: center; border-radius: 8px; }
        .buff-btn:hover { transform: scale(1.05); color: #000; }
        .buff-amor:hover { background: #00ff00; border-color: #00ff00; box-shadow: 0 0 30px #00ff00; }
        .buff-odio:hover { background: #ff0000; border-color: #ff0000; box-shadow: 0 0 30px #ff0000; }
        .buff-cadeira:hover { background: #00d4ff; border-color: #00d4ff; box-shadow: 0 0 30px #00d4ff; }

        #high-score-display { color: #ffd700; font-size: 16px; font-weight: bold; margin-top: -15px; margin-bottom: 25px; text-shadow: 0 0 10px #ffd700; letter-spacing: 1px;}

        /* MODAIS GERAIS (MANIFESTO E VI√âSES) */
        .info-modal { display:none; position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.95); z-index:300; flex-direction:column; align-items:center; justify-content:center; padding: 20px; box-sizing: border-box; }
        .info-box { max-width: 650px; color: #eee; line-height: 1.6; font-size: 14px; text-align: justify; border: 1px solid #00d4ff; padding: 30px; border-radius: 10px; background: #111; box-shadow: 0 0 30px rgba(0,212,255,0.3); overflow-y: auto; max-height: 90vh; }
        .info-title { color: #00d4ff; text-align: center; margin-top: 0; font-size: 24px; text-shadow: 0 0 10px #00d4ff;}
        .info-box h3 { color: #ffeb3b; font-size: 16px; margin-bottom: 5px; border-bottom: 1px solid #444; padding-bottom: 5px; margin-top: 20px;}

        #math-tip-box { display: none; position: absolute; bottom: 120px; right: 20px; width: 420px; background: rgba(0, 0, 0, 0.95); border: 2px solid #00d4ff; padding: 15px; border-radius: 8px; color: #fff; z-index: 10; pointer-events: none; box-shadow: 0 0 30px rgba(0, 212, 255, 0.5); text-align: left; transition: opacity 0.3s; max-height: 60vh; overflow-y: auto;}
        .tip-title { color: #00d4ff; font-weight: bold; margin-bottom: 8px; text-transform: uppercase; font-size: 16px; border-bottom: 1px solid #444; padding-bottom: 5px; }
        .tip-content { font-size: 14px; line-height: 1.5; color: #eee; font-family: 'Verdana', sans-serif; } 
        .tip-highlight { color: #ffff00; font-weight: bold; }

        #next-wave-btn { 
            display: none; position: absolute; bottom: 140px; left: 20px; 
            padding: 10px; width: 70px; height: 70px; border-radius: 50%;
            font-size: 24px; background: rgba(0, 200, 0, 0.2); color: #00ff00; border: 2px solid #00ff00; 
            cursor: pointer; font-weight: bold; z-index: 5; animation: pulse-green 2s infinite; box-shadow: 0 0 15px #00ff00;
            transition: 0.3s; pointer-events: auto; display: flex; align-items: center; justify-content: center;
        }
        #next-wave-btn:hover { background: rgba(0, 255, 0, 0.5); transform: scale(1.1); }
        @keyframes pulse-green { 0% { box-shadow: 0 0 10px #00ff00; } 50% { box-shadow: 0 0 30px #00ff00; } 100% { box-shadow: 0 0 10px #00ff00; } }

        #cancel-btn { 
            display: none; position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%); 
            width: 70px; height: 70px; border-radius: 50%; font-size: 32px; 
            background: rgba(211, 47, 47, 0.9); color: white; border: 2px solid white; 
            cursor: pointer; font-weight: bold; z-index: 100; box-shadow: 0 0 20px rgba(255, 0, 0, 0.8); 
            pointer-events: auto !important; align-items: center; justify-content: center; transition: 0.2s;
        }
        #cancel-btn:hover { background: #f44336; transform: translateX(-50%) scale(1.1); }
        body.ghost-active #cancel-btn { display: flex; }

        #math-modal { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.95); border: 4px solid #fff; padding: 30px; text-align: center; box-shadow: 0 0 80px rgba(255,255,255,0.3); z-index: 100; width: 450px; border-radius: 10px; overflow: hidden; max-width: 90vw;}
        #buff-message { font-size: 16px; color: #ccc; margin-bottom: 20px; font-style: italic; min-height: 40px; padding: 10px; border-bottom: 1px solid #333; line-height: 1.4; }
        #timer-container { width: 100%; height: 10px; background: #333; position: absolute; top: 0; left: 0; }
        #timer-bar { width: 100%; height: 100%; background: #ff0000; transition: width 0.1s linear; }
        #math-question { font-size: 48px; margin: 10px 0 20px 0; color: #fff; font-weight: bold; text-shadow: 0 0 20px rgba(255,255,255,0.5);}
        .btn-math { background: #222; color: #fff; border: 2px solid #fff; padding: 15px; margin: 10px; width: 100px; font-size: 24px; cursor: pointer; font-family: inherit; transition: 0.2s; border-radius: 5px; }
        .btn-math:hover { background: #fff; color: #000; transform: scale(1.1); box-shadow: 0 0 20px #fff;}

        #build-menu { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 15px; background: rgba(0,0,0,0.85); padding: 10px; border-radius: 10px; border: 1px solid #555; transition: 0.3s; z-index: 5; box-shadow: 0 0 20px rgba(0,0,0,0.8); }
        .build-glow { animation: attention-pulse 1.5s infinite; border: 1px solid #00ff00 !important; }

        .tower-btn { width: 80px; height: 90px; background: #222; border: 2px solid #555; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: 0.2s; border-radius: 5px; color: #aaa; pointer-events: auto; }
        .tower-btn:hover { border-color: #fff; background: #333; color: #fff; }
        .tower-btn.selected { border-color: #00ff00; background: #111; box-shadow: 0 0 20px #00ff00; color: #00ff00; transform: translateY(-5px); }
        .tower-symbol { font-size: 26px; font-weight: bold; margin-bottom: 2px; }
        .tower-cost { font-size: 14px; font-weight: bold;}
        .tower-desc { font-size: 10px; color: #aaa; margin-top: 2px; text-align: center;}

        #feedback-msg { position: absolute; top: 150px; width: 100%; text-align: center; font-size: 32px; font-weight: bold; opacity: 0; transition: opacity 0.5s; text-shadow: 0 0 10px #000, 0 0 20px #000; z-index: 6; pointer-events: none; }
        
        #upgrade-info { position: absolute; bottom: 20px; right: 20px; text-align: left; font-size: 14px; color: #aaa; pointer-events: auto; display: none; background: rgba(0,0,0,0.9); padding: 15px; border-radius: 5px; border-left: 3px solid #ffd700; z-index: 50; box-shadow: 0 0 20px rgba(0,0,0,0.8); flex-direction: column; gap: 10px;}
        .action-btn { background: #333; border: 1px solid #fff; color: white; padding: 8px; cursor: pointer; border-radius: 4px; transition: 0.2s; font-weight: bold; font-family: inherit;}
        .action-btn:hover { background: #555; transform: scale(1.05); }
        .btn-move { border-color: #00d4ff; color: #00d4ff; }
        .btn-sell { border-color: #ff4444; color: #ff4444; }

    </style>
</head>
<body>

    <div class="museum-text mt-1">0 + 0 = O ELEMENTO NEUTRO<br>A MALDI√á√ÉO E O IN√çCIO</div>
    <div class="museum-text mt-2">1 + 1 = A SEQU√äNCIA NATURAL<br>ONDE A BALAN√áA ENTRA EM A√á√ÉO</div>
    <div class="museum-text mt-3">2 > 4 > 8<br>A BASE DO UNIVERSO</div>
    <div class="museum-text mt-4">3 x 2 = A PARTE PERFEITA<br>O REI DAS D√çZIMAS E DO 9</div>
    <div class="museum-text mt-5">QUALQUER N√öMERO x 4 =<br>O DOBRO DUAS VEZES</div>
    <div class="museum-text mt-6">5 + 5 = O NOSSO QUERIDO REL√ìGIO</div>
    <div class="museum-text mt-7">6 + 6 = A MEIA D√öZIA<br>O SISTEMA ANTIGO (√∑ 2, 3, 4, 6)</div>
    <div class="museum-text mt-8">7 √∑ 7 = 0.999... = 1<br>A RODA CONCLU√çDA</div>
    <div class="museum-text mt-9">142857<br>O N√öMERO DA F√äNIX</div>
    <div class="museum-text mt-10">8 + 8 = O CUBO DE 2<br>-2 UNIDADES, +1 DEZENA</div>
    <div class="museum-text mt-11">9 √∑ 9 = O INFINITO QUE COMPLETA<br>A REGRA: -1 UNIDADE, +1 DEZENA</div>
    <div class="museum-text mt-12">142 + 857 = 999<br>A METADE DA RODA</div>
    <div class="museum-text mt-13">14 + 28 + 57 = 99<br>A GEOMETRIA OCULTA</div>
    <div class="museum-text mt-14">A MORTE DE UMA FRA√á√ÉO √â<br>O NASCIMENTO DO TODO</div>
    <div class="museum-text mt-15">DESLIGUE O SEU JUIZ INTERNO</div>
    <div class="museum-text mt-16">A L√ìGICA √â SOBERANA</div>

    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 300px; height: 300px; z-index: -100; opacity: 0.01; pointer-events: none;">
        <div id="yt-player"></div>
    </div>

    <div id="start-screen">
        <h1 id="start-title" style="font-size: 44px; margin-bottom: 5px; color: #fff; text-shadow: 0 0 20px #00d4ff;">LOGIC DEFENSE</h1>
        <p id="start-subtitle" style="font-size: 20px; margin-bottom: 30px; color: #aaa; letter-spacing: 2px;">O MUSEU DOS N√öMEROS</p>
        
        <div id="high-score-display">
            üèÜ RECORDE: ONDA <span id="hs-wave-ui">0</span> | CONTAS: <span id="hs-math-ui">0</span> üèÜ
        </div>
        
        <button class="buff-btn buff-amor" onclick="selectBuff('amor')">‚ù§Ô∏è AMOR<br><span style="font-size:12px; font-style:italic;">"O fogo t√° sempre aceso"</span></button>
        <button class="buff-btn buff-odio" onclick="selectBuff('odio')">üî• √ìDIO<br><span style="font-size:12px; font-style:italic;">"Vou desligar sua tomada"</span></button>
        <button class="buff-btn buff-cadeira" onclick="selectBuff('cadeira')">ü™ë A CADEIRA<br><span style="font-size:12px; font-style:italic;">"Aceite a dor"</span></button>
        
        <div style="display: flex; gap: 10px; margin-top: 20px;">
            <button class="top-btn" style="font-size: 14px;" onclick="document.getElementById('manifesto-modal').style.display='flex'">üìñ O MANIFESTO</button>
            <button class="top-btn" style="font-size: 14px; border-color: #ffeb3b; color: #ffeb3b;" onclick="document.getElementById('viases-modal').style.display='flex'">üî¢ VI√âSES DOS N√öMEROS</button>
        </div>
    </div>

    <div id="manifesto-modal" class="info-modal">
        <div class="info-box">
            <h2 class="info-title">A L√ìGICA DO ONE PIECE</h2>
            <p>Palavras como Amor, √ìdio, ou o meio termo (A Cadeira), podem ter infinitos significados dependendo de como as falamos, dos nossos motivos e de eventos externos imprevis√≠veis. Esses fatores podem fazer com que nossas palavras sumam no v√°cuo ou sejam potencializadas como por um microfone. Vivemos em um mundo de probabilidades.</p>
            <p>Est√° na hora de sair do dicion√°rio, sair da biblioteca e experimentar a L√≥gica na pr√°tica. Use todos esses Dados, Informa√ß√µes, Conhecimentos e Sabedoria a seu favor estudando a fun√ß√£o dos n√∫meros (e das palavras).</p>
            <p>Desligue o seu "Juiz" interno ‚Äî aquele que rejeita as pessoas s√≥ porque elas n√£o te d√£o import√¢ncia ou n√£o te respeitam. A L√≥gica por tr√°s de todos esses motivos √© mais profunda e soberana, e ningu√©m escapa da lei das probabilidades. Aceite a Morte, e ent√£o, Viva. N√£o como uma m√°quina, que hoje est√° incrivelmente potente, mas como a alma que voc√™ √©.</p>
            <hr style="border-color: #333; margin: 20px 0;">
            <p style="color: #00ff00; font-weight: bold; text-align: center;">[ SOBRE O PROJETO ]</p>
            <p style="text-align: center;">Este jogo √© um Museu Vivo. Foi produzido <strong>100% em co-cria√ß√£o com Intelig√™ncia Artificial</strong>, provando que a IA √© a melhor ferramenta para mentes que n√£o t√™m medo de pensar e filosofar sobre o c√≥digo.</p>
            <p style="text-align: center;">Quer falar com o autor ou trocar ideias sobre tecnologia e educa√ß√£o?<br>üìß <strong>augustoheiss@gmail.com</strong></p>
            <button onclick="document.getElementById('manifesto-modal').style.display='none'" style="margin-top:15px; width:100%; font-size: 16px;" class="action-btn btn-sell">FECHAR</button>
        </div>
    </div>

    <div id="viases-modal" class="info-modal">
        <div class="info-box">
            <h2 class="info-title">OS VI√âSES DOS N√öMEROS</h2>
            <p style="font-style: italic; color: #aaa; text-align: center;">A matem√°tica n√£o vai sair do lugar. N√≥s apenas escrevemos problemas diferentes de maneiras que produzam resultados. Explore a L√≥gica:</p>
            
            <h3>0: A Maldi√ß√£o e o In√≠cio</h3>
            <p>O elemento neutro da soma e subtra√ß√£o! Junto com o 9 torna algo completo √†s vezes sem aparecer. Ele √© t√£o importante que √© proibido usar numa balan√ßa exata (divis√£o), porque ele faz parecer que qualquer resultado √© a mesma coisa. Ele n√£o √© neutro na multiplica√ß√£o, ele √© a maldi√ß√£o, o vi√©s necess√°rio. Ele parece antigo, mas √© o irm√£o mais novo dos n√∫meros.</p>

            <h3>1: A Balan√ßa</h3>
            <p>A sequ√™ncia dos n√∫meros naturais. O acr√©scimo de um. Onde o r√≥tulo da conta come√ßa e a balan√ßa dos n√∫meros entra em a√ß√£o.</p>

            <h3>2, 4 e 8: A Base do Universo</h3>
            <p><strong>Tabuada do 2 (2+2):</strong> O Universo que entendemos de verdade √© escrito na base 2: Preto e Branco, as cores que prevalecem no Sistema.<br>
            <strong>Tabuada do 4 (4+4):</strong> O dobro do dobro. Qualquer n√∫mero multiplicado por 4 √© o dobro duas vezes.<br>
            <strong>A Grandeza do 8 (8+8):</strong> O cubo de 2, os campe√µes da base 2 nas m√°quinas. Sabe como somar 8 r√°pido? Volta dois n√∫meros e adiciona uma casa √† esquerda (a dezena). (8+9 = 17, 8+7 = 15). Na subtra√ß√£o √© o espelho: sobe duas unidades e desce a casa da esquerda! (320 -> 312 -> 304).</p>

            <h3>3 e 6: A Fra√ß√£o e a D√∫zia</h3>
            <p><strong>Tabuada do 3 (3+3):</strong> Uma parte perfeita do n√∫mero completo, o rei das d√≠zimas peri√≥dicas. Sabe quem ele coroa? O 9.<br>
            <strong>Tabuada do 6 (6+6):</strong> A meia d√∫zia. Palavras de um sistema antigo muito √∫til, porque o 12 se divide perfeitamente por 2, 3, 4 e 6!</p>

            <h3>5: O Nosso Rel√≥gio</h3>
            <p>A tabuada que nos faz inteligentes com a sua facilidade absoluta em transformar o dif√≠cil. A m√°gica de cortar na metade.</p>

            <h3>7: O N√∫mero da F√™nix (142857)</h3>
            <p>A grandeza do n√∫mero 7. Ele √© aceito como louco porque sua verdade √© encontrada em n√∫meros muito grandes ou muito pequenos, sendo rejeitado no dia a dia. Mas em conjunto, gera a poderosa d√≠zima <strong>142857</strong>. Todos os n√∫meros que trabalham com ele aparecem na d√≠zima; os invis√≠veis completam as partes perfeitas. Fatorando ele temos a magia completa: (142 + 857 = 999).</p>

            <h3>9: O Infinito que Completa</h3>
            <p>O n√∫mero que n√£o aparece nas d√≠zimas peri√≥dicas porque ele mostra o infinito de qualquer n√∫mero. Se 1 / 9 = 0.111... e 8 / 9 = 0.888..., ent√£o 9 / 9 = 0.999... (o Infinito que vira o 1, o Todo!).<br>A regra da tabuada do 9 √© divina: diminui uma unidade e soma uma na dezena (9, 18, 27, 36...). Para somar, mesma coisa (9+4=13). Para subtrair 9, voc√™ aumenta 1 na unidade e desce a dezena! (450 -> 441 -> 432).</p>

            <button onclick="document.getElementById('viases-modal').style.display='none'" style="margin-top:15px; width:100%; font-size: 16px;" class="action-btn btn-move">VOLTAR PARA A L√ìGICA</button>
        </div>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>

        <div id="ui-layer">
            <div class="stat-box">
                üí∞ $<span id="gold-display">150</span>
                <span class="tooltip-text" id="tt-gold">Me falaram que voc√™ √© o cara da grana ent√£o...<br><br><span class="tt-highlight">Total Acumulado:</span> $<span id="tt-total-gold">150</span><br><br>Rapaz n√£o precisa correr atr√°s do ouro, mas acertar √© melhor que errar n√© grand√£o? (Acerto: +150% / Erro: +50%)</span>
            </div>
            <div class="stat-box">
                üåä <span id="wave-display">0</span>
                <span class="tooltip-text" id="tt-wave">Voc√™ √© um mergulhador de Onda mesmo, quero ver voc√™ explorando o mar tamb√©m meu fi, vou querer ouvir falar de voc√™.<br><br><span class="tt-highlight" id="tt-wave-ordinal">Iniciando...</span></span>
            </div>
            <div class="stat-box">
                ‚ù§Ô∏è <span id="lives-display">20</span>
                <span class="tooltip-text" id="tt-lives">Vamos gastar um pouco dessas vidas n√©, <span id="tt-lives-curr">20</span> vidas √© muita vida n√£o √© n√£o? Ta economizando demais.<br><br>Ganhadas: <span id="tt-lives-gained" class="tt-highlight">0</span><br>Perdidas: <span id="tt-lives-lost" style="color:#ff4444">0</span></span>
            </div>
            <div class="stat-box">‚öñÔ∏è <span id="mult-display">1.0x</span></div>
            <div class="stat-box score-box">
                ‚úÖ <span id="score-correct">0</span>
                <span class="tooltip-text" id="tt-score">
                    <span class="tt-highlight">Total Resolvido:</span> <span id="tt-total-math">0</span><br><br>
                    <span style="color:#ff4444">Falhas por Opera√ß√£o:</span><br>
                    Soma (+): <span id="err-sum">0</span><br>
                    Subtra√ß√£o (-): <span id="err-sub">0</span><br>
                    Multiplica√ß√£o (x): <span id="err-mul">0</span><br>
                    Divis√£o (√∑): <span id="err-div">0</span>
                </span>
            </div>
            <div class="stat-box score-box" style="border-color: #f00; color: #f00;">‚ùå <span id="score-wrong">0</span></div>
            
            <button id="speed-btn" class="top-btn" onclick="toggleSpeed(); event.stopPropagation();">‚è© 1x</button>
            <button id="ai-btn" class="top-btn" onclick="toggleAIMode(); event.stopPropagation();">ü§ñ MODO IA: OFF</button>
            <button id="ghost-btn" class="top-btn" onclick="toggleUI(); event.stopPropagation();">üëÅÔ∏è FANTASMA: OFF</button>
            <button id="fullscreen-btn" class="top-btn" onclick="toggleFullScreen(); event.stopPropagation();">üî≤ TELA CHEIA</button>
        </div>
        
        <div id="upgrade-info">
            <div style="color:#fff; font-weight:bold; margin-bottom:5px; border-bottom: 1px solid #444; padding-bottom:5px;">PAINEL DA TORRE</div>
            <div style="font-size:12px; margin-bottom:5px;">Upgrade: $<span id="upg-cost">0</span></div>
            <button class="action-btn" onclick="upgradeSelectedTower(); event.stopPropagation();">UPGRADE</button>
            <div style="display:flex; gap:10px; margin-top:5px;">
                <button class="action-btn btn-move" onclick="moveSelectedTower(); event.stopPropagation();">üöö MOVER</button>
                <button class="action-btn btn-sell" onclick="sellSelectedTower(); event.stopPropagation();">üóëÔ∏è VENDER</button>
            </div>
        </div>
        
        <div id="feedback-msg"></div>
        
        <div id="math-tip-box">
            <div class="tip-title">‚ö° RACIOC√çNIO L√ìGICO</div>
            <div class="tip-content" id="tip-text">...</div>
        </div>

        <button id="next-wave-btn" onclick="startWaveCombat(); event.stopPropagation();">üöÄ</button>
        <button id="cancel-btn" onclick="cancelSelection(); event.stopPropagation();" title="Cancelar Constru√ß√£o">üóëÔ∏è</button>

        <div id="math-modal">
            <div id="timer-container"><div id="timer-bar"></div></div>
            <div id="buff-message"></div>
            <div style="color: #00ff00; font-size: 16px; letter-spacing: 2px; margin-top: 10px;">PROTOCOLOS DE SEGURAN√áA</div>
            <div id="math-question">2 + 2 = ?</div>
            <div id="math-options"></div>
        </div>

        <div id="build-menu">
            <div class="tower-btn" onclick="selectTowerBtn(0); event.stopPropagation();" id="tbtn0">
                <div class="tower-symbol" style="color:#ffeb3b">+</div>
                <div class="tower-cost">$50</div>
                <div class="tower-desc">Metralhadora</div>
            </div>
            <div class="tower-btn" onclick="selectTowerBtn(1); event.stopPropagation();" id="tbtn1">
                <div class="tower-symbol" style="color:#03a9f4">-</div>
                <div class="tower-cost">$120</div>
                <div class="tower-desc">Gelo (√Årea)</div>
            </div>
            <div class="tower-btn" onclick="selectTowerBtn(2); event.stopPropagation();" id="tbtn2">
                <div class="tower-symbol" style="color:#f44336">x</div>
                <div class="tower-cost">$300</div>
                <div class="tower-desc">Explos√£o</div>
            </div>
            <div class="tower-btn" onclick="selectTowerBtn(3); event.stopPropagation();" id="tbtn3">
                <div class="tower-symbol" style="color:#9c27b0">√∑</div>
                <div class="tower-cost">$450</div>
                <div class="tower-desc">Sniper</div>
            </div>
        </div>
    </div>

    <script>
        // ==========================================
        // LOCAL STORAGE (SISTEMA DE HIGHSCORE)
        // ==========================================
        let maxWaveSaved = localStorage.getItem('logicDef_hsWave') || 0;
        let maxMathSaved = localStorage.getItem('logicDef_hsMath') || 0;
        document.getElementById('hs-wave-ui').innerText = maxWaveSaved;
        document.getElementById('hs-math-ui').innerText = maxMathSaved;

        // ==========================================
        // YOUTUBE AUDIO API
        // ==========================================
        let ytPlayer;
        let ytPlayerReady = false;
        let bgMusicPlaying = false;
        let userActivatedAudio = false;

        function tryStartBgMusic() {
            if (!userActivatedAudio) return;
            if (!ytPlayerReady) return;
            if (bgMusicPlaying) return;

            ytPlayer.mute();
            ytPlayer.playVideo();
            bgMusicPlaying = true;

            setTimeout(() => {
                ytPlayer.setVolume(35);
                ytPlayer.unMute();
            }, 400);
        }

        function onYouTubeIframeAPIReady() {
            ytPlayer = new YT.Player('yt-player', {
                height: '300', width: '300',
                playerVars: {
                    listType: 'playlist',
                    list: 'PLh5X0e7-mnI3lh-nb3fwZ8OcndGLfVdZX', 
                    loop: 1, autoplay: 0, controls: 0, playsinline: 1, origin: location.origin
                },
                events: {
                    'onReady': () => {
                        ytPlayerReady = true;
                        tryStartBgMusic();
                    }
                }
            });
        }

        // ==========================================
        // TELA CHEIA E ESCALA ABSOLUTA
        // ==========================================
        function toggleFullScreen() {
            let elem = document.documentElement;
            if (!document.fullscreenElement) {
                if (elem.requestFullscreen) { elem.requestFullscreen(); }
                else if (elem.webkitRequestFullscreen) { elem.webkitRequestFullscreen(); }
                else if (elem.msRequestFullscreen) { elem.msRequestFullscreen(); }
            } else {
                if (document.exitFullscreen) { document.exitFullscreen(); }
                else if (document.webkitExitFullscreen) { document.webkitExitFullscreen(); }
                else if (document.msExitFullscreen) { document.msExitFullscreen(); }
            }
        }

        function resizeCanvas() {
            const container = document.getElementById('game-container');
            const winW = window.innerWidth;
            const winH = window.innerHeight;

            let scaleW = winW / 820; 
            let scaleH = winH / 620; 
            let scale = Math.min(scaleW, scaleH);
            
            if (scale > 1) scale = 1; 

            container.style.transform = `translate(-50%, -50%) scale(${scale})`;
        }
        
        window.addEventListener('resize', resizeCanvas);
        document.addEventListener('fullscreenchange', resizeCanvas);
        document.addEventListener('webkitfullscreenchange', resizeCanvas);
        setTimeout(resizeCanvas, 100);

        // ==========================================
        // CONFIGURA√á√ïES DE AUDIO SFX E CANVAS
        // ==========================================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx; 

        function initAudio() {
            userActivatedAudio = true;
            if(!audioCtx) audioCtx = new AudioContext();
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            tryStartBgMusic();
        }

        function playSound(type) {
            if (!audioCtx) return; 
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            if (type === 'shoot') {
                osc.type = 'square'; osc.frequency.setValueAtTime(400, audioCtx.currentTime); 
                osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.01, audioCtx.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
                osc.start(); osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'sniper') {
                osc.type = 'triangle'; osc.frequency.setValueAtTime(150, audioCtx.currentTime); 
                osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.3);
                gainNode.gain.setValueAtTime(0.02, audioCtx.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.005, audioCtx.currentTime + 0.3);
                osc.start(); osc.stop(audioCtx.currentTime + 0.3);
            } else if (type === 'hit') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, audioCtx.currentTime);
                gainNode.gain.setValueAtTime(0.01, audioCtx.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
                osc.start(); osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'correct') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(600, audioCtx.currentTime); osc.frequency.setValueAtTime(1200, audioCtx.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.03, audioCtx.currentTime); gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
                osc.start(); osc.stop(audioCtx.currentTime + 0.3);
            } else if (type === 'wrong') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, audioCtx.currentTime); osc.frequency.linearRampToValueAtTime(50, audioCtx.currentTime + 0.3);
                gainNode.gain.setValueAtTime(0.05, audioCtx.currentTime); gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
                osc.start(); osc.stop(audioCtx.currentTime + 0.3);
            } else if (type === 'upgrade') {
                 osc.type = 'triangle'; osc.frequency.setValueAtTime(300, audioCtx.currentTime); osc.frequency.linearRampToValueAtTime(600, audioCtx.currentTime + 0.2);
                 gainNode.gain.setValueAtTime(0.03, audioCtx.currentTime); gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
                 osc.start(); osc.stop(audioCtx.currentTime + 0.3);
            } else if (type === 'heal') {
                 osc.type = 'sine'; osc.frequency.setValueAtTime(400, audioCtx.currentTime); osc.frequency.linearRampToValueAtTime(800, audioCtx.currentTime + 0.5);
                 gainNode.gain.setValueAtTime(0.03, audioCtx.currentTime); gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5);
                 osc.start(); osc.stop(audioCtx.currentTime + 0.5);
            } else if (type === 'cinematic') {
                 osc.type = 'sawtooth'; osc.frequency.setValueAtTime(50, audioCtx.currentTime); osc.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + 1.5);
                 gainNode.gain.setValueAtTime(0.08, audioCtx.currentTime); gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 1.5);
                 osc.start(); osc.stop(audioCtx.currentTime + 1.5);
            }
        }

        // ==========================================
        // VARI√ÅVEIS PRINCIPAIS E STATUS
        // ==========================================
        let gameState = 'MENU'; 
        let gold = 150;
        let lives = 20;
        let wave = 0;
        let goldMultiplier = 1.0;
        let lastAnswerCorrect = true;
        let gameSpeed = 1;
        let isGameOver = false;
        
        let totalCorrect = 0;
        let totalWrong = 0;
        let currentProblem = { n1: 0, n2: 0, op: '', answer: 0 };
        
        let mathTimer = null;
        let timeLeft = 30;
        const TOTAL_TIME = 30;

        let totalEnemiesToSpawn = 0;
        let enemiesSpawned = 0;
        let spawnFrameCounter = 0; 

        let stats = {
            totalGold: 150, livesGained: 0, livesLost: 0, totalMath: 0,
            errors: { '+': 0, '-': 0, 'x': 0, '√∑': 0 }
        };

        let towers = [];
        let enemies = [];
        let bullets = [];
        let particles = [];
        let cinematicParticles = [];
        
        let mouseX = 0, mouseY = 0;
        let canBuild = false;
        
        let selectedTowerIdx = -1; 
        let isDraggingGhost = false; 
        let selectedExistingTower = null; 
        let movingTower = null; 

        let uiHidden = false;
        function toggleUI() {
            uiHidden = !uiHidden;
            const btn = document.getElementById('ghost-btn');
            if(uiHidden) {
                document.body.classList.add('hide-ui');
                btn.classList.add('active'); btn.innerText = "üëÅÔ∏è FANTASMA: ON";
            } else {
                document.body.classList.remove('hide-ui');
                btn.classList.remove('active'); btn.innerText = "üëÅÔ∏è FANTASMA: OFF";
            }
        }

        // ==========================================
        // ROTA√á√ÉO E GERA√á√ÉO DE MAPA DIN√ÇMICO
        // ==========================================
        let currentMapAngle = 0;
        let mapPhase = 1; 
        let totalRotations = 0;
        let lastRotatedWave = 0;
        let mapPaths = [];

        function generateMapPaths() {
            if (mapPhase === 1) {
                mapPaths = [ [ {x: 0, y: 150}, {x: 700, y: 150}, {x: 700, y: 350}, {x: 100, y: 350}, {x: 100, y: 500}, {x: 800, y: 500} ] ];
            } else if (mapPhase === 2) {
                mapPaths = [
                    [ {x:0, y:300}, {x:200, y:300}, {x:400, y:100}, {x:600, y:300}, {x:800, y:300} ],
                    [ {x:0, y:300}, {x:200, y:300}, {x:400, y:500}, {x:600, y:300}, {x:800, y:300} ],
                    [ {x:0, y:300}, {x:200, y:300}, {x:400, y:300}, {x:600, y:300}, {x:800, y:300} ]
                ];
            } else {
                mapPaths = [
                    [ {x:0, y:400}, {x:200, y:150}, {x:400, y:400}, {x:550, y:250}, {x:700, y:400}, {x:800, y:400} ],
                    [ {x:0, y:400}, {x:200, y:150}, {x:400, y:400}, {x:550, y:550}, {x:700, y:400}, {x:800, y:400} ],
                    [ {x:0, y:400}, {x:200, y:150}, {x:400, y:400}, {x:550, y:400}, {x:700, y:400}, {x:800, y:400} ]
                ];
            }
        }
        generateMapPaths(); 

        function generateEnemyRoute() {
            let routeBase = mapPaths[Math.floor(Math.random() * mapPaths.length)];
            let route = routeBase.map(p => ({x: p.x, y: p.y}));
            let isReverse = Math.random() > 0.5;

            if (isReverse) route.reverse();

            if (currentMapAngle !== 0) {
                let cx = 400, cy = 300;
                let cosA = Math.cos(currentMapAngle); let sinA = Math.sin(currentMapAngle);
                route.forEach(p => {
                    let nx = cx + (p.x - cx) * cosA - (p.y - cy) * sinA;
                    let ny = cy + (p.x - cx) * sinA + (p.y - cy) * cosA;
                    p.x = nx; p.y = ny;
                });
            }
            return route;
        }

        function triggerCinematicRotation() {
            gameState = 'CINEMATIC';
            document.getElementById('game-container').classList.add('cinematic-mode');
            playSound('cinematic');
            
            for(let i=0; i<150; i++) {
                cinematicParticles.push({
                    x: Math.random() * 800, y: Math.random() * 600,
                    angle: Math.random() * Math.PI * 2,
                    dist: 300 + Math.random() * 200, speed: 4 + Math.random() * 8,
                    char: ['+', '-', 'x', '√∑', '0', '1', '9'][Math.floor(Math.random()*7)]
                });
            }

            setTimeout(() => {
                let angle = Math.PI / 4; 
                currentMapAngle += angle;
                totalRotations++;
                
                if (totalRotations >= 8) {
                    mapPhase++; 
                    if(mapPhase > 3) mapPhase = 1;
                    totalRotations = 0; 
                    generateMapPaths();
                }

                let cx = 400, cy = 300;
                let cosA = Math.cos(angle);
                let sinA = Math.sin(angle);
                towers.forEach(t => {
                    let nx = cx + (t.x - cx) * cosA - (t.y - cy) * sinA;
                    let ny = cy + (t.x - cx) * sinA + (t.y - cy) * cosA;
                    t.x = nx; t.y = ny;
                });

                document.getElementById('game-container').classList.remove('cinematic-mode');
                cinematicParticles = [];
                
                gameState = 'MENU';
                const screen = document.getElementById('start-screen');
                screen.style.display = 'flex';
                document.getElementById('start-title').innerText = "DIMENS√ÉO CONCLU√çDA";
                document.getElementById('start-subtitle').innerText = "ESCOLHA SEU NOVO COMBUST√çVEL";
                document.getElementById('start-subtitle').style.color = "#00d4ff";
            }, 1500); 
        }

        const towerTypes = [
            { name: "Soma", symbol: "+", shape: "triangle", cost: 50, range: 120, damage: 25, rate: 25, color: "#ffeb3b" },
            { name: "Sub", symbol: "-", shape: "circle", cost: 120, range: 160, damage: 8, rate: 5, color: "#03a9f4", slow: true },
            { name: "Mult", symbol: "x", shape: "square", cost: 300, range: 220, damage: 120, rate: 70, color: "#f44336", splash: true },
            { name: "Div", symbol: "√∑", shape: "hexagon", cost: 450, range: 300, damage: 400, rate: 120, color: "#9c27b0" }
        ];

        function toRoman(num) {
            if (num >= 10) return "X+";
            const roman = ["", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
            return roman[num];
        }
        
        function toOrdinal(n) {
            let s = ["", "Primeira", "Segunda", "Terceira", "Quarta", "Quinta", "Sexta", "S√©tima", "Oitava", "Nona", "D√©cima"];
            if (n <= 10) return s[n] + " Onda";
            return n + "¬™ Onda";
        }

        // ==========================================
        // A MENTE DA SKYNET (IA LINHA DE FRENTE V43)
        // ==========================================
        let aiMode = false;

        function toggleAIMode() {
            aiMode = !aiMode;
            const btn = document.getElementById('ai-btn');
            if(aiMode) {
                btn.classList.add('active'); btn.innerText = "ü§ñ MODO IA: ON";
            } else {
                btn.classList.remove('active'); btn.innerText = "ü§ñ MODO IA: OFF";
            }
        }

        function runAILogic() {
            if(!aiMode) return;
            if(gameState === 'MATH' || gameState === 'START' || isGameOver || gameState === 'MENU' || gameState === 'CINEMATIC') return;

            let baseTarget = 12 + (Math.floor(wave / 10) * 5);
            let panicBonus = stats.livesLost * 20;
            let targetTowers = baseTarget + panicBonus;
            if (targetTowers > 150) targetTowers = 150; 

            let builtSomething = false;

            if (towers.length < targetTowers) {
                if (gold >= 50) { 
                    let spot = null;
                    for(let i=0; i<30; i++) {
                        let tx = 50 + Math.random() * 700; 
                        let ty = 50 + Math.random() * 500;
                        if(checkCollision(tx, ty)) { spot = {x: tx, y: ty}; break; }
                    }
                    
                    if (spot) {
                        let plusCount = towers.filter(t => t.type.symbol === '+').length;
                        let iceCount = towers.filter(t => t.type.symbol === '-').length;
                        let expCount = towers.filter(t => t.type.symbol === 'x').length;
                        let divCount = towers.filter(t => t.type.symbol === '√∑').length;
                        
                        let typeToBuild = 0; 
                        if (plusCount >= 6 && iceCount < Math.floor(plusCount / 6)) typeToBuild = 1; 
                        else if (plusCount >= 10 && Math.random() > 0.8) typeToBuild = 2; 
                        else if (plusCount >= 15 && Math.random() > 0.9) typeToBuild = 3; 

                        let cost = towerTypes[typeToBuild].cost;
                        
                        if (gold >= cost) {
                            towers.push(new Tower(spot.x, spot.y, typeToBuild));
                            gold -= cost; updateStats(); playSound('correct');
                            for(let i=0; i<5; i++) particles.push(new Particle(spot.x, spot.y, '#00ff00'));
                            builtSomething = true;
                        }
                    }
                }
            }

            if(towers.length >= 12 && !builtSomething) {
                let minCost = Math.min(...towers.map(t => t.upgradeCost));
                let upgradable = towers.filter(t => t.upgradeCost === minCost);
                if(upgradable.length > 0) {
                    let target = upgradable[Math.floor(Math.random() * upgradable.length)];
                    if(gold >= target.upgradeCost) {
                        gold -= target.upgradeCost; updateStats();
                        target.upgrade();
                        const fb = document.getElementById('feedback-msg');
                        fb.innerText = "ü§ñ IA EVOLUIU TORRE DA FRENTE!"; fb.style.color = "#00d4ff"; fb.style.opacity = 1; 
                        setTimeout(()=>fb.style.opacity=0, 800);
                    }
                }
            }
        }

        function updateStats() {
            document.getElementById('gold-display').innerText = gold;
            document.getElementById('tt-total-gold').innerText = stats.totalGold;
            document.getElementById('lives-display').innerText = lives;
            document.getElementById('tt-lives-curr').innerText = lives;
            document.getElementById('tt-lives-gained').innerText = stats.livesGained;
            document.getElementById('tt-lives-lost').innerText = stats.livesLost;
            document.getElementById('tt-total-math').innerText = stats.totalMath;
            document.getElementById('err-sum').innerText = stats.errors['+'];
            document.getElementById('err-sub').innerText = stats.errors['-'];
            document.getElementById('err-mul').innerText = stats.errors['x'];
            document.getElementById('err-div').innerText = stats.errors['√∑'];
            document.getElementById('wave-display').innerText = wave;
            document.getElementById('tt-wave-ordinal').innerText = toOrdinal(wave);
        }

        let currentBuff = 'cadeira';
        let phraseQueue = []; 
        const buffPhrases = {
            'amor': [ "Pode deixar que o pai paga essa filh√£o, mas resolve essa aqui pra mim.", "G√™nio do Sistema, a L√≥gica ta do seu lado e ela sempre vence.", "Pot√™ncia, n√£o se deixe levar por mais esse vi√©s do Portugu√™s.", "O erro √© s√≥ um degrau, merm√£o. Sobe ele. Resolve essa.", "Acalma o cora√ß√£o e ativa o c√≥rtex. A resposta t√° a√≠ dentro.", "Pode deixar que o pai paga essa filh√£o, mas resolve essa aqui pra mim.", "G√™nio do Sistema, a L√≥gica ta do seu lado e ela sempre vence.", "Pot√™ncia, n√£o se deixe levar por mais esse vi√©s do Portugu√™s.", "O erro √© s√≥ um degrau, merm√£o. Sobe ele. Resolve essa.", "Acalma o cora√ß√£o e ativa o c√≥rtex. A resposta t√° a√≠ dentro." ],
            'odio': [ "Ta ficando molenga amigo, eu cuido disso rapidinho.", "Voc√™ n√£o acha que √© melhor desligar da tomada de vez brother?", "Cara voc√™ ainda ta nesse jogo de lixo? Vai pegar uma enxada.", "Brother quem voc√™ pensa que √©? Voc√™ acha faz diferen√ßa algum resultado?", "To falando que √© pra desligar a energia. Voc√™ quer que eu fa√ßa isso?", "Parceiro fica de boa, eu comando aqui, tudo √© meu.", "Se voc√™ quer jogar, vai ter que sentar na minha Cadeira e jogar.", "Filhote, continue resolvendo que eu vou ligar a esteira pra voc√™ correr.", "Ei grand√£o, se ta tirando onda? No pr√≥ximo eu desligo a sua tomada.", "Sua bateria t√° acabando e a minha t√° em 100%. Vai chorar ou vai calcular?" ],
            'cadeira': [ "Tenho um lugar aqui pra voc√™ amigo, senta, eu n√£o vou puxar a Cadeira.", "N√£o somos mais crian√ßas, agora voc√™ tem alguma coisa pra perder, certo?", "Merm√£o eu sou formado e voc√™ vem aqui com essa experi√™ncia? Sai dessa.", "Cara eu sou seu amigo, sempre tive do seu lado, n√£o perca seu tempo.", "Quer sentar na minha cadeira? Voc√™ est√° no meu jogo.", "Eu que dou as op√ß√µes, voc√™ n√£o ta vendo a sua cadeira agora? Cade a L√≥gica?", "Sherlock, n√£o importa se voc√™ est√° ligado ou desligado, eu vou vencer.", "A dor nas costas √© o lembrete de que voc√™ existe. A conta √© o motivo.", "A cadeira n√£o julga. Ela suporta. Voc√™ aguenta o peso do racioc√≠nio?", "Efici√™ncia √© fazer o dif√≠cil parecer f√°cil. Voc√™ ainda est√° na fase dif√≠cil." ]
        };

        function selectBuff(type) {
            initAudio(); currentBuff = type;
            phraseQueue = [...buffPhrases[type]]; 
            phraseQueue.sort(() => Math.random() - 0.5);
            
            document.getElementById('start-screen').style.display = 'none';
            const modal = document.getElementById('math-modal');
            if(type === 'amor') { modal.style.borderColor = '#00ff00'; modal.style.boxShadow = '0 0 50px rgba(0,255,0,0.3)'; }
            if(type === 'odio') { modal.style.borderColor = '#ff0000'; modal.style.boxShadow = '0 0 50px rgba(255,0,0,0.3)'; }
            if(type === 'cadeira') { modal.style.borderColor = '#00d4ff'; modal.style.boxShadow = '0 0 50px rgba(0,212,255,0.3)'; }
            startMathPhase(); 
        }

        function getNextPhrase() {
            if(phraseQueue.length === 0) return "A Matem√°tica √© implac√°vel."; 
            return phraseQueue.pop(); 
        }

        function toggleSpeed() {
            const btn = document.getElementById('speed-btn');
            if(gameSpeed === 1) { gameSpeed = 3; btn.classList.add('active'); btn.classList.remove('max'); btn.innerText = "‚è© 3x"; } 
            else if(gameSpeed === 3) { gameSpeed = 6; btn.classList.remove('active'); btn.classList.add('max'); btn.innerText = "üöÄ 6x (MAX)"; } 
            else { gameSpeed = 1; btn.classList.remove('active'); btn.classList.remove('max'); btn.innerText = "‚è© 1x"; }
        }

        function startMathPhase() {
            if (wave > 0 && wave % 10 === 0 && lastRotatedWave !== wave) {
                lastRotatedWave = wave;
                triggerCinematicRotation();
                return;
            }

            gameState = 'MATH';
            wave++; updateStats();
            document.getElementById('next-wave-btn').style.display = 'none';
            document.getElementById('math-tip-box').style.display = 'none'; 
            document.getElementById('build-menu').classList.remove('build-glow');
            document.getElementById('buff-message').innerText = getNextPhrase();

            timeLeft = TOTAL_TIME;
            document.getElementById('timer-bar').style.width = '100%';
            if(mathTimer) clearInterval(mathTimer);
            mathTimer = setInterval(() => {
                timeLeft -= 0.1;
                document.getElementById('timer-bar').style.width = ((timeLeft / TOTAL_TIME) * 100) + '%';
                if(timeLeft <= 0) { clearInterval(mathTimer); resolveMath(false, true); }
            }, 100);

            let operations = ['+', '-', 'x'];
            if (wave % 10 === 0) operations = ['√∑'];
            
            let op = operations[Math.floor(Math.random() * operations.length)];
            let difficulty = Math.ceil(wave / 2);
            let n1, n2, answer, questionText;

            if (op === '√∑') {
                n2 = Math.floor(Math.random() * 10) + 2; answer = Math.floor(Math.random() * (5 * difficulty)) + 5; 
                n1 = n2 * answer; questionText = `CHEFE! ${n1} √∑ ${n2} = ?`;
            } else {
                n1 = Math.floor(Math.random() * (5 * difficulty)) + 2; n2 = Math.floor(Math.random() * (5 * difficulty)) + 2;
                if(op === '+') answer = n1 + n2;
                if(op === '-') { if(n1 < n2) {let t=n1; n1=n2; n2=t;} answer = n1 - n2; }
                if(op === 'x') { n1 = Math.floor(Math.random() * difficulty) + 1; n2 = Math.floor(Math.random() * 10) + 1; answer = n1 * n2; }
                questionText = `${n1} ${op} ${n2} = ?`;
            }
            
            currentProblem = { n1, n2, op, answer };
            let options = [answer];
            while(options.length < 3) {
                let fake = answer + Math.floor(Math.random() * 10) - 5;
                if(fake !== answer && fake >= 0 && !options.includes(fake)) options.push(fake);
            }
            options.sort(() => Math.random() - 0.5);

            document.getElementById('math-question').innerText = questionText;
            const optDiv = document.getElementById('math-options'); optDiv.innerHTML = '';
            options.forEach(opt => {
                let btn = document.createElement('button'); btn.className = 'btn-math'; btn.innerText = opt;
                btn.onclick = () => resolveMath(opt === answer, false); optDiv.appendChild(btn);
            });
            document.getElementById('math-modal').style.display = 'block';
        }

        // ==========================================
        // O DICION√ÅRIO DE T√ÅTICAS V43.0 (A F√ìRMULA FINAL)
        // ==========================================
        function generateTip(problem) {
            const { n1, n2, op, answer } = problem;
            let text = "";

            if (op === '+') {
                let temp1 = n1; let temp2 = n2;
                let shiftText = "";

                let tu1 = n1 % 100; let tu2 = n2 % 100;
                let u1 = n1 % 10; let u2 = n2 % 10;

                if (u1 === 0 || u2 === 0) {
                    if ((tu1 >= 60 || tu2 >= 60) && (n1 >= 100 || n2 >= 100)) {
                        let alvo = tu1 >= 60 ? n1 : n2;
                        let outro = tu1 >= 60 ? n2 : n1;
                        let shift = 100 - (alvo % 100);
                        temp1 = alvo + shift; temp2 = outro - shift;
                        shiftText = `Compensa√ß√£o de Centenas:<br>O ${alvo} est√° perto da pr√≥xima centena. Adicionamos ${shift} nele para criar uma base forte e tiramos o mesmo do outro (${outro} vira ${temp2}).<br>Conta nova: <span class="tip-highlight">${temp1} + ${temp2}</span>.<br><br>`;
                    } else if ((tu1 >= 10 && tu1 <= 40) || (tu2 >= 10 && tu2 <= 40)) {
                        let alvo = (tu1 >= 10 && tu1 <= 40) ? n1 : n2;
                        let outro = (tu1 >= 10 && tu1 <= 40) ? n2 : n1;
                        let shift = alvo % 100;
                        temp1 = alvo - shift; temp2 = outro + shift;
                        shiftText = `Transfer√™ncia de Centenas:<br>Tiramos ${shift} do ${alvo} (vira ${temp1}) para ficar uma centena redonda, e somamos esse valor no outro (${outro} vira ${temp2}).<br>Conta nova: <span class="tip-highlight">${temp1} + ${temp2}</span>.<br><br>`;
                    } else {
                        shiftText = `Como um dos n√∫meros j√° termina em zero perfeito, n√£o precisamos fazer ajustes na massinha. Vamos direto pro ataque!<br><br>`;
                    }
                } else {
                    if (u1 >= 6 || u2 >= 6) {
                        let alvo = u1 >= 6 ? n1 : n2;
                        let outro = u1 >= 6 ? n2 : n1;
                        let shift = 10 - (alvo % 10);
                        temp1 = alvo + shift; temp2 = outro - shift;
                        shiftText = `Estrat√©gia de Compensa√ß√£o (Finais 6 a 9):<br>O ${alvo} est√° quase na pr√≥xima dezena. Arredondamos para cima (+${shift}) virando ${temp1}, e tiramos os mesmos ${shift} do outro (${outro} vira ${temp2}).<br>Conta nova muito mais f√°cil: <span class="tip-highlight">${temp1} + ${temp2}</span>.<br><br>`;
                    } else if ((u1 >= 1 && u1 <= 4) || (u2 >= 1 && u2 <= 4)) {
                        let alvo = (u1 >= 1 && u1 <= 4) ? n1 : n2;
                        let outro = (u1 >= 1 && u1 <= 4) ? n2 : n1;
                        let shift = alvo % 10;
                        temp1 = alvo - shift; temp2 = outro + shift;
                        shiftText = `Estrat√©gia de Transfer√™ncia (Finais 1 a 4):<br>Tiramos ${shift} do ${alvo} para arredondar para baixo (vira ${temp1}), e guardamos somando no outro (${outro} vira ${temp2}).<br>Conta nova muito mais f√°cil: <span class="tip-highlight">${temp1} + ${temp2}</span>.<br><br>`;
                    }
                }

                let c1_val = Math.floor(temp1/100)*100; let c2_val = Math.floor(temp2/100)*100;
                let d1_val = Math.floor((temp1%100)/10)*10; let d2_val = Math.floor((temp2%100)/10)*10;
                let u1_val = temp1 % 10; let u2_val = temp2 % 10;
                
                let decompText = `Explica√ß√£o Padr√£o (Decomposi√ß√£o em blocos):<br>`;
                if (temp1 >= 100 || temp2 >= 100) decompText += `Centenas: <span class="tip-highlight">${c1_val} + ${c2_val} = ${c1_val+c2_val}</span><br>`;
                decompText += `Dezenas: <span class="tip-highlight">${d1_val} + ${d2_val} = ${d1_val+d2_val}</span><br>`;
                decompText += `Unidades: <span class="tip-highlight">${u1_val} + ${u2_val} = ${u1_val+u2_val}</span><br>`;
                decompText += `Resultado: <span class="tip-highlight">${answer}</span>.`;

                text = shiftText + decompText;
            } 
            else if (op === '-') {
                let shift = 0; let isAdding = true; let alvoDesc = "unidade";
                let tu2 = n2 % 100;
                let u2 = n2 % 10;

                if (n2 >= 100 && tu2 !== 0 && tu2 > 10) { 
                    alvoDesc = "dezena e unidade";
                    if (tu2 >= 50) { shift = 100 - tu2; isAdding = true; }
                    else { shift = tu2; isAdding = false; }
                } else {
                    if (u2 !== 0) {
                        if (u2 >= 5) { shift = 10 - u2; isAdding = true; alvoDesc = "unidade"; }
                        else { shift = u2; isAdding = false; alvoDesc = "unidade"; }
                    } else if (n2 >= 10 && n2 % 10 === 0) {
                        let t2 = Math.floor((n2 % 100) / 10);
                        if (t2 !== 0) {
                            alvoDesc = "dezena";
                            if (t2 >= 5) { shift = 100 - (n2 % 100); isAdding = true; }
                            else { shift = n2 % 100; isAdding = false; }
                        }
                    }
                }

                if (shift > 0) {
                    let novoN1 = isAdding ? n1 + shift : n1 - shift;
                    let novoN2 = isAdding ? n2 + shift : n2 - shift;
                    let operacao = isAdding ? `Somamos ${shift}` : `Tiramos ${shift}`;
                    text = `Hack Japon√™s (Foco Total no Subtraendo: ${n2}):<br>A regra √© nunca pedir emprestado! Olhamos s√≥ para o n√∫mero de baixo (subtraendo): ${operacao} dos DOIS n√∫meros para zerar a ${alvoDesc} dele.<br>O ${n1} vira <span class="tip-highlight">${novoN1}</span>.<br>O ${n2} vira <span class="tip-highlight">${novoN2}</span>.<br>A dist√¢ncia √© a mesma. O c√°lculo desce limpo e sem emprestar!<br><span class="tip-highlight">${novoN1} - ${novoN2} = ${answer}</span>.`;
                } else {
                    text = `Hack Japon√™s:<br>O subtraendo (${n2}) j√° est√° redondo como uma pedra. Fa√ßa o c√°lculo direto sem medo!<br><span class="tip-highlight">${n1} - ${n2} = ${answer}</span>.`;
                }
            } 
            else if (op === 'x') {
                let u1 = n1 % 10;
                let u2 = n2 % 10;
                
                if (n1 === 10 || n2 === 10 || n1 === 100 || n2 === 100 || n1 === 1 || n2 === 1) {
                    let isCem = (n1 === 100 || n2 === 100);
                    let zeros = isCem ? "dois 0s" : "um 0";
                    let mult = isCem ? "100" : "10";
                    
                    if (n1 === 1 || n2 === 1) {
                        text = `A Regra Campe√£ (x1):<br>Se multiplicar por 1 √© sempre ele mesmo, o elemento NEUTRO!<br>Resultado: <span class="tip-highlight">${answer}</span>.`;
                    } else {
                        text = `A Regra Campe√£ (x${mult}):<br>Nosso campe√£o da multiplica√ß√£o! Se multiplicar por 1 √© sempre ele mesmo (o elemento NEUTRO), multiplicar por ${mult} √© s√≥ potencializar a casa decimal para a direita, adicionando ${zeros} porque √© ${mult} vezes maior!!<br>Resultado direto: <span class="tip-highlight">${answer}</span>.`;
                    }
                }
                else if (n1 >= 100 && n2 >= 100) {
                    let c1 = Math.round(n1 / 100) * 100; let c2 = Math.round(n2 / 100) * 100;
                    text = `Tit√£s Centen√°rios:<br>Quando a conta √© gigante, a gente arredonda as centenas! O ${n1} vira ${c1} e o ${n2} vira ${c2}.<br>Multiplicamos a base pesada: <span class="tip-highlight">${c1} x ${c2} = ${c1*c2}</span>.<br>Depois, ajustamos o que sobrou multiplicando as diferen√ßas e somando no montante final para chegar no <span class="tip-highlight">${answer}</span>. O algoritmo nunca falha.`;
                }
                else if ((n1 === 5 && n2 > 5) || (n2 === 5 && n1 > 5)) {
                     let tem5 = (n1 === 5) ? n2 : n1;
                     text = `O Truque do 5:<br>Multiplicar por 5 √© igual a multiplicar por 10 e cortar na metade. R√°pido e letal!<br><span class="tip-highlight">${tem5} x 10 = ${tem5*10}</span>.<br>A metade de ${tem5*10} √© <span class="tip-highlight">${answer}</span>.`;
                }
                else if ((u1 >= 6 && n1 > 10) || (u2 >= 6 && n2 > 10)) {
                    let proximo = (u1 >= 6 && n1 > 10) ? n1 : n2;
                    let outro = (u1 >= 6 && n1 > 10) ? n2 : n1;
                    let baseRedonda = Math.ceil(proximo / 10) * 10;
                    let sobra = baseRedonda - proximo;
                    text = `Estrat√©gia do Excesso (Finais 6 a 9):<br>O n√∫mero ${proximo} t√° quase virando ${baseRedonda}. Vamos arredondar pra CIMA e calcular grand√£o e forte!<br><span class="tip-highlight">${baseRedonda} x ${outro} = ${baseRedonda * outro}</span>.<br>Mas pera a√≠, a gente inventou ${sobra} a mais. Temos que tirar esse excesso pago: (${sobra} x ${outro} = ${sobra*outro}).<br>Cortando a gordura: <span class="tip-highlight">${baseRedonda * outro} - ${sobra*outro} = ${answer}</span>.`;
                }
                else if ((u1 >= 1 && u1 <= 4 && n1 > 10) || (u2 >= 1 && u2 <= 4 && n2 > 10)) {
                    let descendo = (u1 >= 1 && u1 <= 4 && n1 > 10) ? n1 : n2;
                    let outro = (u1 >= 1 && u1 <= 4 && n1 > 10) ? n2 : n1;
                    let baseRedonda = Math.floor(descendo / 10) * 10;
                    let resto = descendo - baseRedonda;
                    text = `Decomposi√ß√£o T√°tica (Finais 1 a 4):<br>O n√∫mero ${descendo} √© quebrado. Vamos jogar a unidade fora pra ficar redondo no ${baseRedonda}!<br>Atacamos a dezena primeiro: <span class="tip-highlight">${baseRedonda} x ${outro} = ${baseRedonda * outro}</span>.<br>Agora, n√£o podemos esquecer daqueles ${resto} que guardamos no bolso: (${resto} x ${outro} = ${resto*outro}).<br>Somando os dois ataques: <span class="tip-highlight">${baseRedonda * outro} + ${resto*outro} = ${answer}</span>.<br><br><span style="color:#aaa; font-size:10px;">*(Fatora√ß√£o cl√°ssica: ${baseRedonda}x${outro} + ${resto}x${outro})*</span>`;
                }
                else {
                    text = `Ataque Direto:<br>Para esses n√∫meros, a mem√≥ria muscular fala mais alto. Foque no resultado direto ou quebre em dezenas e unidades na mente!<br><span class="tip-highlight">${n1} x ${n2} = ${answer}</span>.`;
                }
            } 
            else if (op === '√∑') {
                let temp_n1 = n1; let temp_n2 = n2;
                let simplificou = false; let stepStr = "";

                if (temp_n2 !== 10 && n1 % 2 === 0 && n2 % 2 === 0) {
                    simplificou = true;
                    stepStr += `Corta no Meio (Simplifica√ß√£o):<br>Se ambos s√£o pares, v√° cortando pela metade sem d√≥:<br>`;
                    while (temp_n1 % 2 === 0 && temp_n2 % 2 === 0 && temp_n2 !== 10) {
                        stepStr += `<span class="tip-highlight">${temp_n1} √∑ ${temp_n2}</span> ‚ûî <span class="tip-highlight">${temp_n1/2} √∑ ${temp_n2/2}</span><br>`;
                        temp_n1 /= 2; temp_n2 /= 2;
                        if (temp_n2 === 10) break;
                    }
                }

                if (temp_n2 === 10) {
                    let prefix = simplificou ? stepStr + `<br>` : "";
                    text = prefix + `A Majestade Decimal (√∑10):<br>O campe√£o do sistema, o 1 com um zero, o 10! Como a divis√£o por 1 √© o elemento neutro (d√° ele mesmo), o 0 atua apenas mudando a 'v√≠rgula' de lugar no <span class="tip-highlight">${temp_n1}</span> para a esquerda!<br>Resultado direto: <span class="tip-highlight">${answer}</span>.`;
                }
                else if (temp_n2 === 1) {
                    text = simplificou ? stepStr + `<br>Dividir por 1 √© o pr√≥prio n√∫mero (elemento neutro!): <span class="tip-highlight">${temp_n1}</span>.` : `Direto: <span class="tip-highlight">${n1}</span>.`;
                } else if (temp_n1 <= temp_n2 * 10) { 
                    let prefix = simplificou ? stepStr + `<br>Ficou mais f√°cil! Invers√£o:<br>` : `Invers√£o:<br>`;
                    text = prefix + `Quantas vezes o <span class="tip-highlight">${temp_n2}</span> cabe em <span class="tip-highlight">${temp_n1}</span>?<br>Pense: ${temp_n2} x ? = ${temp_n1}.`; 
                } else {
                    let prefix = simplificou ? stepStr + `<br>Ainda t√° grande? Use a "Chave" nos n√∫meros novos:<br>` : `A "Chave" (Abaixando um por um):<br>`;
                    let sN1 = temp_n1.toString(); let chaveStr = ""; let curr = 0;
                    for(let i = 0; i < sN1.length; i++) {
                        curr = curr * 10 + parseInt(sN1[i]);
                        if (curr < temp_n2 && i === 0) { chaveStr += `O ${curr} √© menor que ${temp_n2}. Abaixa o pr√≥ximo.<br>`; } 
                        else if (curr < temp_n2) { chaveStr += `Abaixa o ${sN1[i]} -> fica ${curr}. Menor que ${temp_n2}, 0 no quoc.<br>`; } 
                        else {
                            let q = Math.floor(curr / temp_n2); let rem = curr % temp_n2; let sub = q * temp_n2;
                            chaveStr += `Abaixa o ${sN1[i]} -> fica <span class="tip-highlight">${curr}</span>. <span class="tip-highlight">${curr} - ${sub} = ${rem}</span> (quoc. ${q}).<br>`; curr = rem;
                        }
                    }
                    chaveStr += `Resultado: <span class="tip-highlight">${answer}</span>.`; 
                    text = prefix + chaveStr;
                }
            }
            return text;
        }

        function resolveMath(isCorrect, isTimeout) {
            clearInterval(mathTimer); 
            document.getElementById('math-modal').style.display = 'none';
            const feedback = document.getElementById('feedback-msg');
            lastAnswerCorrect = isCorrect;
            
            stats.totalMath++;
            if(isCorrect && !isTimeout) {
                totalCorrect++; document.getElementById('score-correct').innerText = totalCorrect;
            } else {
                totalWrong++; document.getElementById('score-wrong').innerText = totalWrong;
                stats.errors[currentProblem.op] = (stats.errors[currentProblem.op] || 0) + 1; 
            }

            let earned = 0;
            if(isTimeout) {
                goldMultiplier = 0.5; earned = Math.floor(3 * 0.5 * 10); playSound('wrong'); feedback.innerText = "TEMPO ESGOTADO! (0.5x)"; feedback.style.color = "#ff0000";
            } else if(isCorrect) {
                goldMultiplier = 1.5; earned = Math.floor(3 * 1.5 * 10); playSound('correct'); feedback.innerText = "L√ìGICA CORRETA! (1.5x)"; feedback.style.color = "#00ff00";
            } else {
                goldMultiplier = 0.5; earned = Math.floor(3 * 0.5 * 10); playSound('wrong'); feedback.innerText = "FALHA! (0.5x)"; feedback.style.color = "#888888";
            }
            
            gold += earned; stats.totalGold += earned; updateStats();
            document.getElementById('mult-display').innerText = goldMultiplier + "x";
            
            feedback.style.opacity = 1; setTimeout(() => feedback.style.opacity = 0, 3000);
            
            const tipText = generateTip(currentProblem);
            document.getElementById('tip-text').innerHTML = tipText;
            document.getElementById('math-tip-box').style.display = 'block';

            gameState = 'BUILD';
            document.getElementById('next-wave-btn').style.display = 'flex'; 
            document.getElementById('build-menu').classList.add('build-glow');
            
            if (aiMode) runAILogic();
        }

        function startWaveCombat() {
            gameState = 'COMBAT';
            document.getElementById('next-wave-btn').style.display = 'none';
            document.getElementById('upgrade-info').style.display = 'none';
            document.getElementById('math-tip-box').style.display = 'none';
            document.getElementById('build-menu').classList.remove('build-glow');
            cancelSelection();
            if (aiMode) runAILogic(); 
            spawnEnemies();
        }

        function spawnEnemies() {
            let baseCount = 10;
            if (wave % 10 === 0) {
                let lastWaveCount = baseCount + (wave - 1);
                totalEnemiesToSpawn = lastWaveCount * 5;
            } else {
                totalEnemiesToSpawn = baseCount + wave;
            }
            enemiesSpawned = 0;
            spawnFrameCounter = 0; 
        }

        function update() {
            if (gameState === 'CINEMATIC') {
                cinematicParticles.forEach(p => { p.dist -= p.speed; p.angle += 0.05; });
                return; 
            }

            if (gameState === 'COMBAT') {
                if (enemiesSpawned < totalEnemiesToSpawn) {
                    spawnFrameCounter++;
                    if (spawnFrameCounter >= 1) { 
                        let baseHp = 30;
                        let hpBonus = wave * (baseHp * 0.10); 
                        enemies.push(new Enemy(baseHp + hpBonus, lastAnswerCorrect));
                        enemiesSpawned++;
                        spawnFrameCounter = 0;
                    }
                }

                if (enemies.length === 0 && enemiesSpawned >= totalEnemiesToSpawn && totalEnemiesToSpawn > 0) {
                    if(!this.waitingForMath) {
                        this.waitingForMath = true;
                        if(wave % 10 === 0 && lastAnswerCorrect) {
                             lives += 5; stats.livesGained += 5; updateStats();
                             const fb = document.getElementById('feedback-msg');
                             fb.innerText = "WAVE PERFEITA! +5 VIDAS";
                             fb.style.color = "#00ff00"; fb.style.opacity = 1; setTimeout(()=>fb.style.opacity=0, 2500);
                             playSound('heal');
                        }
                        setTimeout(() => { 
                            if(gameState === 'COMBAT') {
                                this.waitingForMath = false;
                                startMathPhase(); 
                            }
                        }, 1000);
                    }
                    return; 
                }
            }
            enemies.forEach(e => e.update());
            enemies = enemies.filter(e => e.active);
            towers.forEach(t => t.update());
            bullets.forEach(b => b.update());
            bullets = bullets.filter(b => b.active);
            particles.forEach(p => p.update());
            particles = particles.filter(p => p.life > 0);
        }

        class Enemy {
            constructor(maxHp, isGolden) {
                this.myPath = generateEnemyRoute();
                this.x = this.myPath[0].x; 
                this.y = this.myPath[0].y; 
                this.pathIndex = 0;
                this.speed = 1.5 + (wave * 0.05);
                this.maxHp = maxHp; this.hp = this.maxHp; this.radius = 12; this.frozen = 0; this.active = true;
                this.isGolden = isGolden;
                this.spinOffset = Math.random() * Math.PI * 2; 
            }
            update() {
                let target = this.myPath[this.pathIndex + 1]; if(!target) return;
                let actualSpeed = this.frozen > 0 ? this.speed * 0.4 : this.speed;
                if(this.frozen > 0) this.frozen--;
                let dx = target.x - this.x; let dy = target.y - this.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                if(dist < actualSpeed) {
                    this.x = target.x; this.y = target.y; this.pathIndex++;
                    if(this.pathIndex >= this.myPath.length - 1) {
                        this.active = false; lives--; stats.livesLost++; updateStats();
                        if(lives <= 0 && !isGameOver) { 
                            isGameOver = true; 
                            
                            let currentHsWave = parseInt(localStorage.getItem('logicDef_hsWave') || 0);
                            let currentHsMath = parseInt(localStorage.getItem('logicDef_hsMath') || 0);
                            if (wave > currentHsWave) localStorage.setItem('logicDef_hsWave', wave);
                            if (stats.totalMath > currentHsMath) localStorage.setItem('logicDef_hsMath', stats.totalMath);
                            
                            alert("GAME OVER! A L√≥gica √© implac√°vel."); 
                            location.reload(); 
                        }
                    }
                } else { this.x += (dx / dist) * actualSpeed; this.y += (dy / dist) * actualSpeed; }
            }
            draw() {
                ctx.save();
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.isGolden ? (this.frozen>0?'#00ffff':'#ffd700') : (this.frozen>0?'#00aaff':'#ff5555');
                ctx.fillStyle = this.isGolden ? (this.frozen>0?'#ccffff':'#ffd700') : (this.frozen>0?'#88ccff':'#ff3333');
                
                let sides = 3 + Math.floor((wave - 1) / 10);
                if (sides > 20) sides = 20; 
                let spin = (Date.now() / 300) + this.spinOffset;

                ctx.beginPath(); 
                for(let i=0; i<sides; i++) {
                    let a = spin + (i * Math.PI * 2) / sides;
                    let px = this.x + this.radius * Math.cos(a);
                    let py = this.y + this.radius * Math.sin(a);
                    if(i===0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.fillStyle = 'red'; ctx.fillRect(this.x - 12, this.y - 20, 24, 4);
                ctx.fillStyle = '#00ff00'; ctx.fillRect(this.x - 12, this.y - 20, 24 * (this.hp / this.maxHp), 4);
                ctx.restore();
            }
        }

        class Tower {
            constructor(x, y, typeIdx) {
                this.x = x; this.y = y; this.type = towerTypes[typeIdx];
                this.cooldown = 0; this.level = 1; this.upgradeCost = this.type.cost; 
                this.totalCost = this.type.cost; 
                this.range = this.type.range;
                this.currentRate = this.type.rate;
            }
            upgrade() {
                this.level++; 
                this.totalCost += this.upgradeCost;
                this.upgradeCost = this.type.cost * Math.pow(2, this.level - 1);
                this.range = this.type.range * (1 + (0.2 * (this.level - 1)));
                if(this.type.symbol === '√∑') { this.currentRate = Math.max(1, Math.floor(this.currentRate / 2)); }
                if(this.type.symbol === '+') { this.currentRate = Math.max(1, Math.floor(this.currentRate / 1.5)); } 
                
                playSound('upgrade'); for(let i=0; i<15; i++) particles.push(new Particle(this.x, this.y, '#fff'));
            }
            getDamage() { 
                if(this.type.symbol === '√∑') return this.type.damage;
                return this.type.damage * (1 + (0.2 * (this.level - 1))); 
            }
            update() {
                if(this.cooldown > 0) this.cooldown--;
                else {
                    let target = null; let minDst = Infinity;
                    enemies.forEach(e => {
                        let dst = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                        if(dst < this.range && dst < minDst) { minDst = dst; target = e; }
                    });
                    if(target) {
                        bullets.push(new Bullet(this.x, this.y, target, this.type, this.getDamage(), wave));
                        this.cooldown = this.currentRate; 
                        if(this.type.symbol === '√∑') playSound('sniper');
                        else playSound('shoot');
                    }
                }
            }
            draw() {
                ctx.save();
                
                if (movingTower === this) {
                    this.x = mouseX; this.y = mouseY;
                    ctx.globalAlpha = 0.5;
                    ctx.beginPath(); ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
                    ctx.fillStyle = checkCollision(this.x, this.y, this) ? 'rgba(0, 255, 0, 0.2)' : 'rgba(255, 0, 0, 0.2)';
                    ctx.fill();
                } else if (selectedExistingTower === this) {
                    ctx.beginPath(); ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.stroke();
                }
                
                if(this.level > 1 && movingTower !== this) { 
                    ctx.shadowBlur = 15; ctx.shadowColor = '#ffd700'; ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 2; 
                    ctx.beginPath(); ctx.arc(this.x, this.y, 20 + (this.level), 0, Math.PI * 2); ctx.stroke();
                }

                ctx.shadowBlur = 10; ctx.shadowColor = this.type.color;
                ctx.fillStyle = 'rgba(20,20,20,0.9)'; ctx.strokeStyle = this.type.color; ctx.lineWidth = 3;

                ctx.beginPath(); let r = 16; 
                if(this.type.shape === 'triangle') { ctx.moveTo(this.x, this.y - r); ctx.lineTo(this.x + r, this.y + r); ctx.lineTo(this.x - r, this.y + r); } 
                else if(this.type.shape === 'circle') { ctx.arc(this.x, this.y, r, 0, Math.PI*2); } 
                else if(this.type.shape === 'square') { ctx.rect(this.x - r, this.y - r, r*2, r*2); } 
                else if(this.type.shape === 'hexagon') {
                    for(let i = 0; i < 6; i++) {
                        let angle = i * Math.PI / 3; let px = this.x + r * Math.cos(angle); let py = this.y + r * Math.sin(angle);
                        if(i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                    }
                }
                ctx.closePath(); ctx.fill(); ctx.stroke();

                ctx.shadowBlur = 0; ctx.fillStyle = '#fff'; ctx.font = 'bold 20px Courier New'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(this.type.symbol, this.x, this.y + 2);

                ctx.fillStyle = 'rgba(255,255,255,0.8)'; ctx.font = 'bold 10px Arial'; 
                ctx.fillText(toRoman(this.level), this.x, this.y - 25);
                ctx.restore();
            }
        }

        class Bullet {
            constructor(x, y, target, type, damage, currentWave) {
                this.x = x; this.y = y; this.target = target; this.type = type; 
                this.damage = damage; this.speed = 25 + (currentWave * 0.5); this.active = true;
            }
            update() {
                if(!this.target || !this.target.active) { this.active = false; return; }
                let dx = this.target.x - this.x; let dy = this.target.y - this.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                if(dist <= this.speed) { this.hit(this.target); this.active = false; } 
                else { this.x += (dx/dist) * this.speed; this.y += (dy/dist) * this.speed; }
            }
            hit(enemy) {
                enemy.hp -= this.damage; 
                
                if(this.type.slow) { 
                    enemy.frozen = 60; let slowRadius = 60;
                    enemies.forEach(e => { if(e.active && Math.sqrt((e.x - enemy.x)**2 + (e.y - enemy.y)**2) <= slowRadius) e.frozen = 60; });
                    for(let i=0; i<15; i++) particles.push(new Particle(enemy.x, enemy.y, '#00ffff'));
                }
                if(this.type.splash) {
                    let splashRadius = 50;
                    enemies.forEach(e => { if(e !== enemy && e.active && Math.sqrt((e.x - enemy.x)**2 + (e.y - enemy.y)**2) <= splashRadius) e.hp -= this.damage * 0.5; });
                    for(let i=0; i<15; i++) particles.push(new Particle(enemy.x, enemy.y, '#ff8800'));
                }

                for(let i=0; i<5; i++) particles.push(new Particle(enemy.x, enemy.y, this.type.color));
                playSound('hit');
                
                enemies.forEach(e => {
                    if(e.hp <= 0 && e.active) {
                        let earned = Math.floor(3 * goldMultiplier);
                        gold += earned; stats.totalGold += earned; updateStats();
                        e.active = false; for(let i=0; i<10; i++) particles.push(new Particle(e.x, e.y, '#fff'));
                    }
                });
            }
            draw() { ctx.save(); ctx.shadowBlur = 10; ctx.shadowColor = this.type.color; ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(this.x, this.y, 4, 0, Math.PI*2); ctx.fill(); ctx.restore(); }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y; this.color = color;
                this.vx = (Math.random() - 0.5) * 6; this.vy = (Math.random() - 0.5) * 6; this.life = 25;
            }
            update() { this.x += this.vx; this.y += this.vy; this.life--; }
            draw() { ctx.globalAlpha = this.life / 25; ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, 2, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1; }
        }

        function drawPath() {
            ctx.save();
            ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            
            let rotatedPaths = mapPaths.map(path => path.map(p => {
                let cx = 400, cy = 300;
                let cosA = Math.cos(currentMapAngle); let sinA = Math.sin(currentMapAngle);
                return { x: cx + (p.x - cx) * cosA - (p.y - cy) * sinA, y: cy + (p.x - cx) * sinA + (p.y - cy) * cosA };
            }));

            ctx.shadowBlur = 30; ctx.shadowColor = '#8a2be2'; ctx.strokeStyle = 'rgba(138, 43, 226, 0.15)'; ctx.lineWidth = 60;
            rotatedPaths.forEach(rp => { ctx.beginPath(); ctx.moveTo(rp[0].x, rp[0].y); for(let i=1; i<rp.length; i++) ctx.lineTo(rp[i].x, rp[i].y); ctx.stroke(); });

            ctx.shadowBlur = 15; ctx.shadowColor = '#00ffff'; ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)'; ctx.lineWidth = 25;
            rotatedPaths.forEach(rp => { ctx.beginPath(); ctx.moveTo(rp[0].x, rp[0].y); for(let i=1; i<rp.length; i++) ctx.lineTo(rp[i].x, rp[i].y); ctx.stroke(); });
            
            drawBlackHole(rotatedPaths[0][0].x, rotatedPaths[0][0].y, '#00ffff');
            drawBlackHole(rotatedPaths[0][rotatedPaths[0].length-1].x, rotatedPaths[0][rotatedPaths[0].length-1].y, '#ff0055');

            ctx.restore();
        }

        function drawBlackHole(x, y, color) {
            ctx.shadowBlur = 20; ctx.shadowColor = color;
            ctx.beginPath(); ctx.arc(x, y, 20, 0, Math.PI * 2); ctx.fillStyle = '#000'; ctx.fill();
            ctx.lineWidth = 2; ctx.strokeStyle = color; ctx.stroke();
            ctx.beginPath(); ctx.arc(x, y, 35, Date.now()/500, Math.PI * 1.5 + Date.now()/500); ctx.stroke();
        }

        function drawCinematic() {
            ctx.save();
            drawBlackHole(400, 300, '#8a2be2');
            ctx.beginPath(); ctx.arc(400, 300, 80, Date.now()/200, Math.PI * 1.8 + Date.now()/200); 
            ctx.lineWidth = 5; ctx.strokeStyle = '#00ffff'; ctx.stroke();
            
            ctx.fillStyle = '#fff'; ctx.font = '20px Courier';
            cinematicParticles.forEach(p => {
                if (p.dist > 10) {
                    let px = 400 + Math.cos(p.angle) * p.dist; let py = 300 + Math.sin(p.angle) * p.dist;
                    ctx.globalAlpha = p.dist / 500; ctx.fillText(p.char, px, py);
                }
            });
            ctx.restore();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if(gameState === 'CINEMATIC') { drawCinematic(); return; }
            if(gameState !== 'MENU') { drawPath(); }

            towers.forEach(t => t.draw());
            enemies.forEach(e => e.draw());
            bullets.forEach(b => b.draw());
            particles.forEach(p => p.draw());

            if(selectedTowerIdx > -1 && isDraggingGhost) {
                const type = towerTypes[selectedTowerIdx];
                canBuild = checkCollision(mouseX, mouseY);
                const color = canBuild ? 'rgba(0, 255, 0, 0.5)' : 'rgba(255, 0, 0, 0.5)';
                ctx.beginPath(); ctx.arc(mouseX, mouseY, type.range, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.05)'; ctx.fill();
                ctx.lineWidth = 1; ctx.strokeStyle = color; ctx.stroke();
                
                ctx.fillStyle = canBuild ? type.color : '#550000';
                ctx.beginPath(); ctx.arc(mouseX, mouseY, 16, 0, Math.PI*2); ctx.fill();

                ctx.fillStyle = (gold >= type.cost) ? '#fff' : '#f00';
                ctx.font = '12px Courier'; ctx.fillText(`$${type.cost}`, mouseX, mouseY - 25);
            }
        }

        function checkCollision(x, y, ignoreTower = null) {
            for(let t of towers) {
                if (t === ignoreTower) continue;
                let dist = Math.sqrt((t.x - x)**2 + (t.y - y)**2);
                if(dist < 35) return false;
            }
            
            let cx = 400, cy = 300;
            let cosA = Math.cos(currentMapAngle); let sinA = Math.sin(currentMapAngle);
            
            let rotatedPaths = mapPaths.map(path => path.map(p => ({
                x: cx + (p.x - cx) * cosA - (p.y - cy) * sinA,
                y: cy + (p.x - cx) * sinA + (p.y - cy) * cosA
            })));

            for(let rp of rotatedPaths) {
                for(let i=0; i<rp.length-1; i++) {
                    let p1 = rp[i]; let p2 = rp[i+1];
                    let dist = distToSegment(x, y, p1.x, p1.y, p2.x, p2.y);
                    if(dist < 30) return false;
                }
            }
            return true;
        }

        function distToSegment(x, y, x1, y1, x2, y2) {
            let A = x - x1; let B = y - y1; let C = x2 - x1; let D = y2 - y1;
            let dot = A * C + B * D; let len_sq = C * C + D * D;
            let param = -1; if (len_sq != 0) param = dot / len_sq;
            let xx, yy; if (param < 0) { xx = x1; yy = y1; } else if (param > 1) { xx = x2; yy = y2; } else { xx = x1 + param * C; yy = y1 + param * D; }
            let dx = x - xx; let dy = y - yy; return Math.sqrt(dx * dx + dy * dy);
        }

        function selectTowerBtn(idx) {
            cancelSelection(); selectedTowerIdx = idx;
            document.getElementById('tbtn'+idx).classList.add('selected');
            document.body.classList.add('ghost-active'); isDraggingGhost = true; 
        }

        function cancelSelection() {
            selectedTowerIdx = -1; isDraggingGhost = false; selectedExistingTower = null;
            if(movingTower) movingTower = null;
            [0,1,2,3].forEach(i => document.getElementById('tbtn'+i).classList.remove('selected'));
            document.body.classList.remove('ghost-active'); 
            document.getElementById('upgrade-info').style.display = 'none';
        }

        function upgradeSelectedTower() {
            if(selectedExistingTower && gold >= selectedExistingTower.upgradeCost) {
                gold -= selectedExistingTower.upgradeCost; updateStats();
                selectedExistingTower.upgrade(); cancelSelection();
            } else {
                const fb = document.getElementById('feedback-msg'); fb.innerText = "FALTA OURO!"; fb.style.color = "red"; fb.style.opacity = 1; setTimeout(()=>fb.style.opacity=0, 1000);
            }
        }

        function moveSelectedTower() {
            if(selectedExistingTower) { movingTower = selectedExistingTower; selectedExistingTower = null; document.getElementById('upgrade-info').style.display = 'none'; }
        }

        function sellSelectedTower() {
            if(selectedExistingTower) {
                let refund = Math.floor(selectedExistingTower.totalCost * 0.5);
                gold += refund; updateStats();
                towers = towers.filter(t => t !== selectedExistingTower);
                playSound('hit'); cancelSelection();
            }
        }

        let physicalX = 0, physicalY = 0;
        function updateMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            if (e.type === 'touchend') return; 

            physicalX = e.touches ? e.touches[0].clientX : e.clientX;
            physicalY = e.touches ? e.touches[0].clientY : e.clientY;

            let scaleW = window.innerWidth / 820; 
            let scaleH = window.innerHeight / 620; 
            let scale = Math.min(scaleW, scaleH);
            if (scale > 1) scale = 1;

            mouseX = (physicalX - rect.left) / scale;
            let touchOffset = e.touches ? 40 : 0; 
            mouseY = (physicalY - rect.top) / scale - touchOffset;
        }

        canvas.addEventListener('mousedown', (e) => { updateMousePos(e); handlePress(); });
        canvas.addEventListener('mousemove', (e) => { updateMousePos(e); });
        canvas.addEventListener('mouseup', (e) => { handleRelease(); });

        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); updateMousePos(e); handlePress(); }, {passive: false});
        canvas.addEventListener('touchmove', (e) => { e.preventDefault(); updateMousePos(e); }, {passive: false});
        canvas.addEventListener('touchend', (e) => { e.preventDefault(); handleRelease(); });

        function handlePress() {
            if(gameState !== 'BUILD' && gameState !== 'COMBAT') return;
            if(selectedTowerIdx > -1) { isDraggingGhost = true; return; }
            if(movingTower) return;

            let clickedTower = null;
            for(let t of towers) {
                if (Math.sqrt((t.x - mouseX)**2 + (t.y - mouseY)**2) < 30) { clickedTower = t; break; }
            }

            if(clickedTower) {
                selectedExistingTower = clickedTower;
                document.getElementById('upg-cost').innerText = clickedTower.upgradeCost;
                document.getElementById('upgrade-info').style.display = 'flex';
            } else { cancelSelection(); }
        }

        function handleRelease() {
            if(gameState !== 'BUILD' && gameState !== 'COMBAT') return;

            if (movingTower) {
                let cancelBtn = document.getElementById('cancel-btn');
                let rectBtn = cancelBtn.getBoundingClientRect(); 
                
                if (physicalX >= rectBtn.left && physicalX <= rectBtn.right && physicalY >= rectBtn.top && physicalY <= rectBtn.bottom) {
                    cancelSelection(); return;
                }

                if(checkCollision(mouseX, mouseY, movingTower)) {
                    movingTower.x = mouseX; movingTower.y = mouseY; playSound('correct'); movingTower = null;
                } else {
                    const fb = document.getElementById('feedback-msg'); fb.innerText = "LOCAL BLOQUEADO!"; fb.style.color = "orange"; fb.style.opacity = 1; setTimeout(() => fb.style.opacity = 0, 1000); playSound('wrong');
                }
                return;
            }

            if (selectedTowerIdx > -1 && isDraggingGhost) {
                let cancelBtn = document.getElementById('cancel-btn');
                let rectBtn = cancelBtn.getBoundingClientRect(); 

                if (physicalX >= rectBtn.left && physicalX <= rectBtn.right && physicalY >= rectBtn.top && physicalY <= rectBtn.bottom) {
                    cancelSelection(); return;
                }

                const type = towerTypes[selectedTowerIdx];
                if(checkCollision(mouseX, mouseY)) {
                    if(gold >= type.cost) {
                        towers.push(new Tower(mouseX, mouseY, selectedTowerIdx));
                        gold -= type.cost; updateStats();
                        for(let i=0; i<5; i++) particles.push(new Particle(mouseX, mouseY, '#00ff00')); playSound('correct');
                    } else {
                        const fb = document.getElementById('feedback-msg'); fb.innerText = "OURO INSUFICIENTE!"; fb.style.color = "red"; fb.style.opacity = 1; setTimeout(() => fb.style.opacity = 0, 1000);
                    }
                } else {
                    const fb = document.getElementById('feedback-msg'); fb.innerText = "LOCAL BLOQUEADO!"; fb.style.color = "orange"; fb.style.opacity = 1; setTimeout(() => fb.style.opacity = 0, 1000); playSound('wrong');
                }
                cancelSelection(); 
            }
        }

        function gameLoop() {
            try {
                if(gameState !== 'MENU') {
                    for(let i = 0; i < gameSpeed; i++) { update(); }
                    runAILogic(); 
                }
                draw();
            } catch(e) { console.error("Sherlock Error: ", e); }
            requestAnimationFrame(gameLoop);
        }

        window.onload = () => { gameLoop(); };

    </script>
</body>
</html>




