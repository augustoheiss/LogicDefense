<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Logic Defense: The Teacher</title>
    <style>
        body { 
            margin: 0; overflow: hidden; background-color: #1a1a1a; color: white; 
            font-family: 'Courier New', monospace; user-select: none; 
            touch-action: none;
        }
        
        #game-container { position: relative; width: 800px; height: 600px; margin: 20px auto; border: 2px solid #444; background: #222; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        canvas { display: block; cursor: crosshair; }
        
        #ui-layer { position: absolute; top: 10px; left: 10px; width: 100%; pointer-events: none; display: flex; flex-wrap: wrap; gap: 10px; transition: opacity 0.3s; }
        .stat-box { background: rgba(0,0,0,0.8); padding: 8px 12px; border: 1px solid #00ff00; color: #00ff00; font-weight: bold; font-size: 14px; border-radius: 4px; }
        .score-box { border-color: #fff; color: #fff; }
        
        #speed-btn {
            pointer-events: auto; background: #333; border: 2px solid #fff; color: white;
            padding: 8px 15px; font-weight: bold; cursor: pointer; border-radius: 4px;
        }
        #speed-btn.active { background: #ff9800; color: black; border-color: #ff9800; box-shadow: 0 0 10px #ff9800; }

        /* ONDE A DICA VAI APARECER */
        #math-tip-box {
            display: none;
            position: absolute;
            bottom: 200px; /* Acima do bot√£o mandar onda */
            right: 40px;
            width: 300px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00d4ff; /* Azul CI√äNCIA */
            padding: 15px;
            border-radius: 8px;
            color: #fff;
            z-index: 10;
            pointer-events: none; /* Deixa clicar atrav√©s se precisar */
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
            text-align: left;
        }
        .tip-title { color: #00d4ff; font-weight: bold; margin-bottom: 5px; text-transform: uppercase; font-size: 14px; }
        .tip-content { font-size: 14px; line-height: 1.4; color: #eee; }
        .tip-highlight { color: #ffff00; font-weight: bold; }

        #next-wave-btn { 
            display: none; position: absolute; bottom: 140px; right: 40px; 
            padding: 15px 30px; font-size: 20px; background: #ff0000; color: white; border: 2px solid white; 
            cursor: pointer; font-weight: bold; z-index: 5; animation: pulse 2s infinite; box-shadow: 0 0 10px #ff0000; border-radius: 5px;
            transition: opacity 0.3s;
        }
        #next-wave-btn:hover { background: #ff4444; transform: scale(1.05); }
        @keyframes pulse { 0% { box-shadow: 0 0 10px #ff0000; } 50% { box-shadow: 0 0 25px #ff0000; } 100% { box-shadow: 0 0 10px #ff0000; } }

        #cancel-btn {
            display: none; position: absolute; top: 80px; left: 50%; transform: translateX(-50%);
            padding: 12px 30px; font-size: 20px; background: #d32f2f; color: white; border: 2px solid white;
            cursor: pointer; font-weight: bold; z-index: 100; border-radius: 50px;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.8); pointer-events: auto !important;
            text-transform: uppercase; letter-spacing: 2px;
        }
        #cancel-btn:hover { background: #f44336; transform: translateX(-50%) scale(1.1); }

        #math-modal { 
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            background: rgba(0,0,0,0.95); border: 4px solid #00ff00; padding: 30px; text-align: center; 
            box-shadow: 0 0 50px #00ff00; z-index: 10; width: 400px; border-radius: 10px; overflow: hidden;
        }
        
        #timer-container { width: 100%; height: 10px; background: #333; position: absolute; top: 0; left: 0; }
        #timer-bar { width: 100%; height: 100%; background: #ff0000; transition: width 0.1s linear; }

        #math-question { font-size: 48px; margin: 30px 0 20px 0; color: #fff; font-weight: bold; }
        .btn-math { 
            background: #222; color: #00ff00; border: 2px solid #00ff00; padding: 15px; margin: 10px; width: 100px;
            font-size: 24px; cursor: pointer; font-family: inherit; transition: 0.2s; border-radius: 5px;
        }
        .btn-math:hover { background: #00ff00; color: #000; transform: scale(1.1); }

        #build-menu { 
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); 
            display: flex; gap: 15px; background: rgba(0,0,0,0.8); padding: 10px; border-radius: 10px; border: 1px solid #555;
            transition: 0.3s;
        }
        .build-glow { animation: attention-pulse 1.5s infinite; border: 1px solid #00ff00 !important; }
        @keyframes attention-pulse { 0% { box-shadow: 0 0 0 rgba(0,255,0,0); border-color:#555; } 50% { box-shadow: 0 0 20px rgba(0,255,0,0.8); border-color:#00ff00; } 100% { box-shadow: 0 0 0 rgba(0,255,0,0); border-color:#555; } }

        .tower-btn { 
            width: 70px; height: 80px; background: #333; border: 2px solid #555; cursor: pointer; 
            display: flex; flex-direction: column; align-items: center; justify-content: center; 
            transition: 0.2s; border-radius: 5px; color: #aaa; pointer-events: auto;
        }
        .tower-btn:hover { border-color: #fff; background: #444; color: #fff; }
        .tower-btn.selected { border-color: #00ff00; background: #111; box-shadow: 0 0 15px #00ff00; color: #00ff00; transform: translateY(-5px); }
        .tower-symbol { font-size: 30px; font-weight: bold; margin-bottom: 5px; }
        .tower-cost { font-size: 14px; }
        .tower-desc { font-size: 10px; color: #888; margin-top: 2px; }

        #feedback-msg { 
            position: absolute; top: 150px; width: 100%; text-align: center; 
            font-size: 28px; font-weight: bold; opacity: 0; transition: opacity 0.5s; 
            text-shadow: 2px 2px 4px #000; z-index: 6; pointer-events: none;
        }
        
        #upgrade-info { position: absolute; top: 10px; right: 10px; text-align: right; font-size: 12px; color: #aaa; pointer-events: none; display: none; }

        body.ghost-active #build-menu, body.ghost-active #next-wave-btn, body.ghost-active #ui-layer { opacity: 0.15; pointer-events: none !important; }
        body.ghost-active .tower-btn { pointer-events: none !important; }
        body.ghost-active #cancel-btn { display: block; }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>

        <div id="ui-layer">
            <div class="stat-box">üí∞ <span id="gold-display">150</span></div>
            <div class="stat-box">üåä <span id="wave-display">0</span></div>
            <div class="stat-box">‚ù§Ô∏è <span id="lives-display">20</span></div>
            <div class="stat-box">‚öñÔ∏è <span id="mult-display">1.0x</span></div>
            <div class="stat-box score-box">‚úÖ <span id="score-correct">0</span></div>
            <div class="stat-box score-box" style="border-color: #f00; color: #f00;">‚ùå <span id="score-wrong">0</span></div>
            <button id="speed-btn" onclick="toggleSpeed()">‚è© 1x</button>
        </div>
        
        <div id="upgrade-info">CLIQUE NA TORRE PARA EVOLUIR</div>

        <div id="feedback-msg"></div>
        
        <div id="math-tip-box">
            <div class="tip-title">‚ö° HACK L√ìGICO</div>
            <div class="tip-content" id="tip-text">...</div>
        </div>

        <button id="next-wave-btn" onclick="startWaveCombat()">MANDAR ONDA!</button>
        <button id="cancel-btn" onclick="cancelSelection()">üóëÔ∏è CANCELAR</button>

        <div id="math-modal">
            <div id="timer-container"><div id="timer-bar"></div></div>
            <div style="color: #00ff00; font-size: 16px; letter-spacing: 2px; margin-top: 10px;">PROTOCOLOS DE SEGURAN√áA</div>
            <div id="math-question">2 + 2 = ?</div>
            <div id="math-options"></div>
        </div>

        <div id="build-menu">
            <div class="tower-btn" onclick="selectTower(0)" id="tbtn0">
                <div class="tower-symbol" style="color:#ffeb3b">+</div>
                <div class="tower-cost">$50</div>
                <div class="tower-desc">R√°pida</div>
            </div>
            <div class="tower-btn" onclick="selectTower(1)" id="tbtn1">
                <div class="tower-symbol" style="color:#03a9f4">-</div>
                <div class="tower-cost">$120</div>
                <div class="tower-desc">Slow</div>
            </div>
            <div class="tower-btn" onclick="selectTower(2)" id="tbtn2">
                <div class="tower-symbol" style="color:#f44336">x</div>
                <div class="tower-cost">$300</div>
                <div class="tower-desc">Explos√£o</div>
            </div>
            <div class="tower-btn" onclick="selectTower(3)" id="tbtn3">
                <div class="tower-symbol" style="color:#9c27b0">√∑</div>
                <div class="tower-cost">$450</div>
                <div class="tower-desc">Acelerador</div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        function resizeCanvas() {
            const container = document.getElementById('game-container');
            const winW = window.innerWidth;
            if (winW < 840) {
                let scale = winW / 820;
                container.style.transform = `scale(${scale})`;
                container.style.transformOrigin = 'top left';
                container.style.marginBottom = '-200px';
            } else {
                container.style.transform = 'scale(1)';
                container.style.marginBottom = '20px';
            }
        }
        window.addEventListener('resize', resizeCanvas);
        setTimeout(resizeCanvas, 100);

        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            if (type === 'shoot') {
                osc.type = 'square'; osc.frequency.setValueAtTime(400, audioCtx.currentTime); 
                osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.05, audioCtx.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.start(); osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'sniper') {
                osc.type = 'triangle'; osc.frequency.setValueAtTime(150, audioCtx.currentTime); 
                osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.3);
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                osc.start(); osc.stop(audioCtx.currentTime + 0.3);
            } else if (type === 'hit') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, audioCtx.currentTime);
                gainNode.gain.setValueAtTime(0.05, audioCtx.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.start(); osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'correct') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(600, audioCtx.currentTime); osc.frequency.setValueAtTime(1200, audioCtx.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime); gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
                osc.start(); osc.stop(audioCtx.currentTime + 0.3);
            } else if (type === 'wrong') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, audioCtx.currentTime); osc.frequency.linearRampToValueAtTime(50, audioCtx.currentTime + 0.3);
                gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime); gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
                osc.start(); osc.stop(audioCtx.currentTime + 0.3);
            } else if (type === 'upgrade') {
                 osc.type = 'triangle'; osc.frequency.setValueAtTime(300, audioCtx.currentTime); osc.frequency.linearRampToValueAtTime(600, audioCtx.currentTime + 0.2);
                 gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime); gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
                 osc.start(); osc.stop(audioCtx.currentTime + 0.3);
            } else if (type === 'heal') {
                 osc.type = 'sine'; osc.frequency.setValueAtTime(400, audioCtx.currentTime); osc.frequency.linearRampToValueAtTime(800, audioCtx.currentTime + 0.5);
                 gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime); gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5);
                 osc.start(); osc.stop(audioCtx.currentTime + 0.5);
            }
        }

        let gameState = 'START';
        let gold = 150;
        let lives = 20;
        let wave = 0;
        let goldMultiplier = 1.0;
        let lastAnswerCorrect = true;
        let gameSpeed = 1;
        let isGameOver = false;
        
        let totalCorrect = 0;
        let totalWrong = 0;
        
        // --- MEM√ìRIA DA CONTA ATUAL ---
        let currentProblem = { n1: 0, n2: 0, op: '', answer: 0 };
        
        let mathTimer = null;
        let timeLeft = 10;
        const TOTAL_TIME = 10;

        let towers = [];
        let enemies = [];
        let bullets = [];
        let particles = [];
        
        let mouseX = 0;
        let mouseY = 0;
        let canBuild = false;

        const path = [
            {x: 0, y: 150}, {x: 700, y: 150}, {x: 700, y: 350}, 
            {x: 100, y: 350}, {x: 100, y: 500}, {x: 800, y: 500}
        ];

        const towerTypes = [
            { name: "Soma", symbol: "+", cost: 50, range: 120, damage: 25, rate: 25, color: "#ffeb3b" },
            { name: "Sub", symbol: "-", cost: 120, range: 160, damage: 8, rate: 5, color: "#03a9f4", slow: true },
            { name: "Mult", symbol: "x", cost: 300, range: 220, damage: 120, rate: 70, color: "#f44336", splash: true },
            { name: "Div", symbol: "√∑", cost: 450, range: 300, damage: 400, rate: 120, color: "#9c27b0" }
        ];
        let selectedTowerIdx = -1;

        function toRoman(num) {
            if (num >= 10) return "X+";
            const roman = ["", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
            return roman[num];
        }

        function toggleSpeed() {
            gameSpeed = (gameSpeed === 1) ? 3 : 1;
            const btn = document.getElementById('speed-btn');
            if(gameSpeed === 3) {
                btn.classList.add('active'); btn.innerText = "‚è© 3x";
            } else {
                btn.classList.remove('active'); btn.innerText = "‚è© 1x";
            }
        }

        function getPathColor(wave) {
            if (wave < 50) return '#333'; 
            if (wave < 100) return '#004488';
            if (wave < 150) return '#440088';
            if (wave < 200) return '#880000';
            return '#b8860b';
        }

        function gameLoop() {
            for(let i = 0; i < gameSpeed; i++) {
                update();
            }
            draw();
            requestAnimationFrame(gameLoop);
        }

        window.onload = () => { startMathPhase(); gameLoop(); };

        function startMathPhase() {
            gameState = 'MATH';
            wave++;
            document.getElementById('wave-display').innerText = wave;
            document.getElementById('next-wave-btn').style.display = 'none';
            document.getElementById('math-tip-box').style.display = 'none'; // Esconde a dica na nova onda
            document.getElementById('build-menu').classList.remove('build-glow');
            
            timeLeft = TOTAL_TIME;
            document.getElementById('timer-bar').style.width = '100%';
            if(mathTimer) clearInterval(mathTimer);
            mathTimer = setInterval(() => {
                timeLeft -= 0.1;
                let pct = (timeLeft / TOTAL_TIME) * 100;
                document.getElementById('timer-bar').style.width = pct + '%';
                if(timeLeft <= 0) { clearInterval(mathTimer); resolveMath(false, true); }
            }, 100);

            let operations = ['+', '-', 'x'];
            if (wave % 10 === 0) operations = ['/'];
            
            let op = operations[Math.floor(Math.random() * operations.length)];
            let difficulty = Math.ceil(wave / 2);
            let n1, n2, answer, questionText;

            if (op === '/') {
                n2 = Math.floor(Math.random() * 10) + 2; 
                answer = Math.floor(Math.random() * (5 * difficulty)) + 5; 
                n1 = n2 * answer; 
                questionText = `CHEFE! ${n1} √∑ ${n2} = ?`;
            } else {
                n1 = Math.floor(Math.random() * (5 * difficulty)) + 2;
                n2 = Math.floor(Math.random() * (5 * difficulty)) + 2;
                if(op === '+') answer = n1 + n2;
                if(op === '-') { if(n1 < n2) {let t=n1; n1=n2; n2=t;} answer = n1 - n2; }
                if(op === 'x') { n1 = Math.floor(Math.random() * difficulty) + 1; n2 = Math.floor(Math.random() * 10) + 1; answer = n1 * n2; }
                questionText = `${n1} ${op} ${n2} = ?`;
            }
            
            // --- GUARDA OS DADOS PRA GERAR A DICA DEPOIS ---
            currentProblem = { n1, n2, op, answer };

            let options = [answer];
            while(options.length < 3) {
                let fake = answer + Math.floor(Math.random() * 10) - 5;
                if(fake !== answer && fake >= 0 && !options.includes(fake)) options.push(fake);
            }
            options.sort(() => Math.random() - 0.5);

            document.getElementById('math-question').innerText = questionText;
            const optDiv = document.getElementById('math-options');
            optDiv.innerHTML = '';
            options.forEach(opt => {
                let btn = document.createElement('button');
                btn.className = 'btn-math';
                btn.innerText = opt;
                btn.onclick = () => resolveMath(opt === answer, false);
                optDiv.appendChild(btn);
            });
            document.getElementById('math-modal').style.display = 'block';
        }

        // --- SISTEMA DE DICAS T√ÅTICAS ---
        function generateTip(problem) {
            const { n1, n2, op, answer } = problem;
            let text = "";

            if (op === '+') {
                let rounded = Math.round(n1/10)*10;
                let diff = n1 - rounded;
                text = `Decomposi√ß√£o: <br>Separe as dezenas e unidades.<br><span class="tip-highlight">${n1} + ${n2}</span> √© igual a <span class="tip-highlight">(${Math.floor(n1/10)*10} + ${Math.floor(n2/10)*10}) + (${n1%10} + ${n2%10})</span>.`;
            } else if (op === '-') {
                let nextTen = Math.ceil(n2/10)*10;
                let diff = nextTen - n2;
                if (diff === 0) diff = 10; // Se j√° for 10, joga pro proximo
                text = `Arredondamento:<br>Aumente o ${n2} para ${nextTen} (soma ${diff}).<br><span class="tip-highlight">${n1} - ${nextTen} = ${n1-nextTen}</span>.<br>Agora DEVOLVA o que pegou: <span class="tip-highlight">${n1-nextTen} + ${diff} = ${answer}</span>.`;
            } else if (op === 'x') {
                text = `Distributiva:<br>Multiplique a dezena e a unidade separado.<br><span class="tip-highlight">${n1} x ${n2}</span> vira <span class="tip-highlight">(${Math.floor(n1/10)*10} x ${n2}) + (${n1%10} x ${n2})</span>.<br>Some os resultados.`;
            } else if (op === '/') {
                text = `Engenharia Reversa:<br>Pense na multiplica√ß√£o.<br>Qual n√∫mero vezes <span class="tip-highlight">${n2}</span> resulta em <span class="tip-highlight">${n1}</span>?<br>Tabuada do ${n2} √© a chave.`;
            }
            return text;
        }

        function resolveMath(isCorrect, isTimeout) {
            clearInterval(mathTimer); 
            document.getElementById('math-modal').style.display = 'none';
            const feedback = document.getElementById('feedback-msg');
            lastAnswerCorrect = isCorrect;
            
            if(isCorrect && !isTimeout) {
                totalCorrect++; document.getElementById('score-correct').innerText = totalCorrect;
            } else {
                totalWrong++; document.getElementById('score-wrong').innerText = totalWrong;
            }

            if(isTimeout) {
                goldMultiplier = 0.5; playSound('wrong'); feedback.innerText = "TEMPO ESGOTADO! (0.5x)"; feedback.style.color = "#ff0000";
            } else if(isCorrect) {
                goldMultiplier = 1.5; playSound('correct'); feedback.innerText = "L√ìGICA CORRETA! (1.5x)"; feedback.style.color = "#00ff00";
            } else {
                goldMultiplier = 0.5; playSound('wrong'); feedback.innerText = "FALHA! (0.5x)"; feedback.style.color = "#888888";
            }
            
            document.getElementById('mult-display').innerText = goldMultiplier + "x";
            feedback.style.opacity = 1; setTimeout(() => feedback.style.opacity = 0, 3000);
            
            // --- EXIBIR A DICA T√ÅTICA ---
            const tipText = generateTip(currentProblem);
            document.getElementById('tip-text').innerHTML = tipText;
            document.getElementById('math-tip-box').style.display = 'block';

            gameState = 'BUILD';
            document.getElementById('next-wave-btn').style.display = 'block';
            document.getElementById('upgrade-info').style.display = 'block';
            document.getElementById('build-menu').classList.add('build-glow');
        }

        function startWaveCombat() {
            gameState = 'COMBAT';
            document.getElementById('next-wave-btn').style.display = 'none';
            document.getElementById('upgrade-info').style.display = 'none';
            document.getElementById('math-tip-box').style.display = 'none'; // Some a dica ao iniciar
            document.getElementById('build-menu').classList.remove('build-glow');
            cancelSelection();
            spawnEnemies();
        }

        function spawnEnemies() {
            let baseCount = 20;
            let count = baseCount + (wave * 5);
            if (wave % 10 === 0) count *= 5; 

            let baseHp = 30;
            let hpBonus = wave * (baseHp * 0.10); 
            
            let spawned = 0;
            let spawnRate = Math.max(100, 1000 - (wave * 20)); 
            if (wave % 10 === 0) spawnRate = 50; 
            
            let interval = setInterval(() => {
                if(gameState !== 'COMBAT') { clearInterval(interval); return; }
                enemies.push(new Enemy(baseHp + hpBonus, lastAnswerCorrect));
                spawned++;
                if(spawned >= count) clearInterval(interval);
            }, spawnRate);
        }

        function update() {
            if (gameState === 'COMBAT') {
                if (enemies.length === 0) {
                    if(!this.waitingForMath) {
                        this.waitingForMath = true;
                        if(wave % 10 === 0 && lastAnswerCorrect) {
                             lives += 5; document.getElementById('lives-display').innerText = lives;
                             const fb = document.getElementById('feedback-msg');
                             fb.innerText = "WAVE PERFEITA! +5 VIDAS";
                             fb.style.color = "#00ff00"; fb.style.opacity = 1; setTimeout(()=>fb.style.opacity=0, 2500);
                             playSound('heal');
                        }
                        setTimeout(() => { 
                            if(gameState === 'COMBAT') {
                                this.waitingForMath = false;
                                startMathPhase(); 
                            }
                        }, 1000);
                    }
                    return; 
                }
            }
            enemies.forEach(e => e.update());
            enemies = enemies.filter(e => e.active);
            towers.forEach(t => t.update());
            bullets.forEach(b => b.update());
            bullets = bullets.filter(b => b.active);
            particles.forEach(p => p.update());
            particles = particles.filter(p => p.life > 0);
        }

        function draw() {
            ctx.fillStyle = '#222'; ctx.fillRect(0, 0, canvas.width, canvas.height);

            if(gameState === 'BUILD' || gameState === 'COMBAT') {
                ctx.strokeStyle = '#333'; ctx.lineWidth = 1;
                for(let i=0; i<800; i+=50) { ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,600); ctx.stroke(); }
                for(let i=0; i<600; i+=50) { ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(800,i); ctx.stroke(); }
            }

            ctx.strokeStyle = getPathColor(wave);
            ctx.lineWidth = 40; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            ctx.beginPath(); ctx.moveTo(path[0].x, path[0].y);
            for(let i=1; i<path.length; i++) ctx.lineTo(path[i].x, path[i].y);
            ctx.stroke();
            ctx.strokeStyle = '#222'; ctx.lineWidth = 2; ctx.stroke();

            towers.forEach(t => t.draw());
            enemies.forEach(e => e.draw());
            bullets.forEach(b => b.draw());
            particles.forEach(p => p.draw());

            if(selectedTowerIdx > -1) {
                const type = towerTypes[selectedTowerIdx];
                canBuild = checkCollision(mouseX, mouseY);
                const color = canBuild ? 'rgba(0, 255, 0, 0.5)' : 'rgba(255, 0, 0, 0.5)';
                ctx.beginPath(); ctx.arc(mouseX, mouseY, type.range, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)'; ctx.fill();
                ctx.lineWidth = 1; ctx.strokeStyle = color; ctx.stroke();
                ctx.fillStyle = canBuild ? type.color : '#550000';
                ctx.fillRect(mouseX - 15, mouseY - 15, 30, 30);
                ctx.fillStyle = (gold >= type.cost) ? '#fff' : '#f00';
                ctx.font = '12px Courier';
                ctx.fillText(`$${type.cost}`, mouseX, mouseY - 25);
            }
            
            if(selectedTowerIdx === -1) {
                for(let t of towers) {
                    let dist = Math.sqrt((t.x - mouseX)**2 + (t.y - mouseY)**2);
                    if(dist < 20) {
                        ctx.beginPath(); ctx.arc(t.x, t.y, t.range, 0, Math.PI * 2);
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)'; ctx.lineWidth = 1; ctx.stroke();
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.05)'; ctx.fill();
                        ctx.fillStyle = (gold >= t.upgradeCost) ? '#0f0' : '#f00';
                        ctx.font = 'bold 14px Arial';
                        ctx.fillText(`UPGRADE: $${t.upgradeCost}`, t.x, t.y - 40);
                        if(t.type.symbol === '√∑') {
                            ctx.fillStyle = '#cc88ff'; ctx.font = '10px Arial';
                            ctx.fillText(`(ACELERAR)`, t.x, t.y - 55);
                        }
                    }
                }
            }
        }

        function checkCollision(x, y) {
            for(let t of towers) {
                let dist = Math.sqrt((t.x - x)**2 + (t.y - y)**2);
                if(dist < 35) return false;
            }
            for(let i=0; i<path.length-1; i++) {
                let p1 = path[i]; let p2 = path[i+1];
                let dist = distToSegment(x, y, p1.x, p1.y, p2.x, p2.y);
                if(dist < 30) return false;
            }
            return true;
        }

        function distToSegment(x, y, x1, y1, x2, y2) {
            let A = x - x1; let B = y - y1; let C = x2 - x1; let D = y2 - y1;
            let dot = A * C + B * D; let len_sq = C * C + D * D;
            let param = -1; if (len_sq != 0) param = dot / len_sq;
            let xx, yy; if (param < 0) { xx = x1; yy = y1; } else if (param > 1) { xx = x2; yy = y2; } else { xx = x1 + param * C; yy = y1 + param * D; }
            let dx = x - xx; let dy = y - yy; return Math.sqrt(dx * dx + dy * dy);
        }

        class Enemy {
            constructor(maxHp, isGolden) {
                this.x = path[0].x; this.y = path[0].y; this.pathIndex = 0;
                this.speed = 1.5 + (wave * 0.05);
                this.maxHp = maxHp; this.hp = this.maxHp; this.radius = 12; this.frozen = 0; this.active = true;
                this.isGolden = isGolden;
            }
            update() {
                let target = path[this.pathIndex + 1]; if(!target) return;
                let actualSpeed = this.frozen > 0 ? this.speed * 0.4 : this.speed;
                if(this.frozen > 0) this.frozen--;
                let dx = target.x - this.x; let dy = target.y - this.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                if(dist < actualSpeed) {
                    this.x = target.x; this.y = target.y; this.pathIndex++;
                    if(this.pathIndex >= path.length - 1) {
                        this.active = false; lives--; 
                        document.getElementById('lives-display').innerText = lives;
                        if(lives <= 0 && !isGameOver) { isGameOver = true; alert("GAME OVER!"); location.reload(); }
                    }
                } else { this.x += (dx / dist) * actualSpeed; this.y += (dy / dist) * actualSpeed; }
            }
            draw() {
                ctx.fillStyle = this.isGolden ? (this.frozen>0?'#ccffff':'#ffd700') : (this.frozen>0?'#88ccff':'#555555');
                ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill();
                ctx.lineWidth = 2; ctx.strokeStyle = '#000'; ctx.stroke();
                ctx.fillStyle = 'red'; ctx.fillRect(this.x - 12, this.y - 20, 24, 4);
                ctx.fillStyle = '#00ff00'; ctx.fillRect(this.x - 12, this.y - 20, 24 * (this.hp / this.maxHp), 4);
            }
        }

        class Tower {
            constructor(x, y, typeIdx) {
                this.x = x; this.y = y; this.type = towerTypes[typeIdx];
                this.cooldown = 0; this.level = 1; this.upgradeCost = this.type.cost; 
                this.range = this.type.range;
                this.currentRate = this.type.rate;
            }
            upgrade() {
                this.level++; 
                this.upgradeCost = this.type.cost * Math.pow(2, this.level - 1);
                this.range = this.type.range * (1 + (0.2 * (this.level - 1)));
                if(this.type.symbol === '√∑') { this.currentRate = Math.max(1, Math.floor(this.currentRate / 2)); }
                playSound('upgrade'); for(let i=0; i<10; i++) particles.push(new Particle(this.x, this.y, '#fff'));
            }
            getDamage() { 
                if(this.type.symbol === '√∑') return this.type.damage;
                return this.type.damage * (1 + (0.2 * (this.level - 1))); 
            }
            update() {
                if(this.cooldown > 0) this.cooldown--;
                else {
                    let target = null; let minDst = Infinity;
                    enemies.forEach(e => {
                        let dst = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                        if(dst < this.range && dst < minDst) { minDst = dst; target = e; }
                    });
                    if(target) {
                        bullets.push(new Bullet(this.x, this.y, target, this.type, this.getDamage(), wave));
                        this.cooldown = this.currentRate; 
                        if(this.type.symbol === '√∑') playSound('sniper');
                        else playSound('shoot');
                    }
                }
            }
            draw() {
                ctx.fillStyle = '#333'; ctx.fillRect(this.x - 18, this.y - 18, 36, 36); 
                if(this.level > 1) { ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 2; ctx.strokeRect(this.x - 18, this.y - 18, 36, 36); }
                ctx.fillStyle = this.type.color; ctx.fillRect(this.x - 15, this.y - 15, 30, 30);
                ctx.fillStyle = 'black'; ctx.font = 'bold 20px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(this.type.symbol, this.x, this.y);
                ctx.fillStyle = 'white'; ctx.font = 'bold 10px Arial'; ctx.fillText(toRoman(this.level), this.x, this.y - 20);
            }
        }

        class Bullet {
            constructor(x, y, target, type, damage, currentWave) {
                this.x = x; this.y = y; this.target = target; this.type = type; 
                this.damage = damage; this.speed = 25 + (currentWave * 0.5); this.active = true;
            }
            update() {
                if(!this.target || !this.target.active) { this.active = false; return; }
                let dx = this.target.x - this.x; let dy = this.target.y - this.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                if(dist <= this.speed) { this.hit(this.target); this.active = false; } 
                else { this.x += (dx/dist) * this.speed; this.y += (dy/dist) * this.speed; }
            }
            hit(enemy) {
                enemy.hp -= this.damage; if(this.type.slow) enemy.frozen = 60;
                for(let i=0; i<3; i++) particles.push(new Particle(enemy.x, enemy.y, this.type.color));
                playSound('hit');
                if(enemy.hp <= 0) {
                    gold += Math.floor(3 * goldMultiplier); document.getElementById('gold-display').innerText = gold;
                    enemy.active = false; for(let i=0; i<8; i++) particles.push(new Particle(enemy.x, enemy.y, '#fff'));
                }
            }
            draw() { ctx.fillStyle = this.type.color; ctx.beginPath(); ctx.arc(this.x, this.y, 4, 0, Math.PI*2); ctx.fill(); }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y; this.color = color;
                this.vx = (Math.random() - 0.5) * 4; this.vy = (Math.random() - 0.5) * 4; this.life = 20;
            }
            update() { this.x += this.vx; this.y += this.vy; this.life--; }
            draw() { ctx.globalAlpha = this.life / 20; ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, 3, 3); ctx.globalAlpha = 1; }
        }

        // --- SISTEMA DE GHOST MODE ---
        function selectTower(idx) {
            if(selectedTowerIdx === idx) {
                cancelSelection();
                return;
            }
            [0,1,2,3].forEach(i => document.getElementById('tbtn'+i).classList.remove('selected'));
            selectedTowerIdx = idx;
            if(idx > -1) {
                document.getElementById('tbtn'+idx).classList.add('selected');
                document.body.classList.add('ghost-active'); 
            } else {
                cancelSelection();
            }
        }

        function cancelSelection() {
            selectedTowerIdx = -1;
            [0,1,2,3].forEach(i => document.getElementById('tbtn'+i).classList.remove('selected'));
            document.body.classList.remove('ghost-active'); 
        }

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height;
            mouseX = (e.clientX - rect.left) * scaleX; mouseY = (e.clientY - rect.top) * scaleY;
        });

        canvas.addEventListener('mousedown', (e) => { handleInteraction(); });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); const rect = canvas.getBoundingClientRect(); const touch = e.touches[0];
            const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height;
            mouseX = (touch.clientX - rect.left) * scaleX; mouseY = ((touch.clientY - rect.top) * scaleY) - 50; 
        }, {passive: false});

        canvas.addEventListener('touchend', (e) => { e.preventDefault(); handleInteraction(); });

        function handleInteraction() {
            if(gameState === 'MATH' || gameState === 'START' || isGameOver) return;
            
            for(let t of towers) {
                let dist = Math.sqrt((t.x - mouseX)**2 + (t.y - mouseY)**2);
                if(dist < 30) {
                    if(gold >= t.upgradeCost) {
                        gold -= t.upgradeCost; document.getElementById('gold-display').innerText = gold;
                        t.upgrade();
                        const fb = document.getElementById('feedback-msg'); fb.innerText = "UPGRADE! -" + t.upgradeCost/2; fb.style.color = "#00ff00"; fb.style.opacity = 1; setTimeout(()=>fb.style.opacity=0, 500);
                        cancelSelection();
                    } else {
                        const fb = document.getElementById('feedback-msg'); fb.innerText = "FALTA OURO: $" + t.upgradeCost; fb.style.color = "red"; fb.style.opacity = 1; setTimeout(()=>fb.style.opacity=0, 1000);
                    }
                    return;
                }
            }
            if(selectedTowerIdx > -1) {
                if(canBuild) {
                    const type = towerTypes[selectedTowerIdx];
                    if(gold >= type.cost) {
                        towers.push(new Tower(mouseX, mouseY, selectedTowerIdx));
                        gold -= type.cost; document.getElementById('gold-display').innerText = gold;
                        for(let i=0; i<5; i++) particles.push(new Particle(mouseX, mouseY, '#00ff00')); playSound('correct');
                    } else {
                        const fb = document.getElementById('feedback-msg'); fb.innerText = "OURO INSUFICIENTE!"; fb.style.color = "red"; fb.style.opacity = 1; setTimeout(() => fb.style.opacity = 0, 1000);
                    }
                } else {
                    const fb = document.getElementById('feedback-msg'); fb.innerText = "LOCAL BLOQUEADO!"; fb.style.color = "orange"; fb.style.opacity = 1; setTimeout(() => fb.style.opacity = 0, 1000); playSound('wrong');
                }
            }
        }
    </script>
</body>
</html>
