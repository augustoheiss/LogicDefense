<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Logic Defense: Automata & Speed</title>
    <style>
        body { 
            margin: 0; overflow: hidden; background-color: #1a1a1a; color: white; 
            font-family: 'Courier New', monospace; user-select: none; 
            touch-action: none;
        }
        
        #game-container { position: relative; width: 800px; height: 600px; margin: 20px auto; border: 2px solid #444; background: #222; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        canvas { display: block; cursor: crosshair; }
        
        #ui-layer { position: absolute; top: 10px; left: 10px; width: calc(100% - 20px); pointer-events: none; display: flex; flex-wrap: wrap; gap: 10px; transition: opacity 0.3s; align-items: center;}
        .stat-box { background: rgba(0,0,0,0.8); padding: 8px 12px; border: 1px solid #00ff00; color: #00ff00; font-weight: bold; font-size: 14px; border-radius: 4px; }
        .score-box { border-color: #fff; color: #fff; }
        
        .top-btn {
            pointer-events: auto; background: #333; border: 2px solid #fff; color: white;
            padding: 8px 15px; font-weight: bold; cursor: pointer; border-radius: 4px; transition: 0.2s;
        }
        .top-btn:hover { transform: scale(1.05); }
        
        #speed-btn.active { background: #ff9800; color: black; border-color: #ff9800; box-shadow: 0 0 10px #ff9800; }
        #speed-btn.max { background: #f44336; color: white; border-color: #f44336; box-shadow: 0 0 15px #f44336; }
        
        #ai-btn.active { background: #00d4ff; color: black; border-color: #00d4ff; box-shadow: 0 0 15px #00d4ff; }

        /* TELA DE IN√çCIO */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 200;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .buff-btn {
            margin: 15px; padding: 20px 40px; font-size: 24px; cursor: pointer;
            border: 2px solid white; background: transparent; color: white;
            font-family: inherit; transition: 0.2s; width: 300px; text-align: center;
        }
        .buff-btn:hover { transform: scale(1.05); color: #000; }
        .buff-amor:hover { background: #00ff00; border-color: #00ff00; box-shadow: 0 0 20px #00ff00; }
        .buff-odio:hover { background: #ff0000; border-color: #ff0000; box-shadow: 0 0 20px #ff0000; }
        .buff-cadeira:hover { background: #00d4ff; border-color: #00d4ff; box-shadow: 0 0 20px #00d4ff; }

        /* CAIXA DE DICAS */
        #math-tip-box {
            display: none; position: absolute; bottom: 200px; right: 40px; width: 360px; 
            background: rgba(0, 0, 0, 0.95); border: 2px solid #00d4ff; padding: 15px;
            border-radius: 8px; color: #fff; z-index: 10; pointer-events: none; 
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.4); text-align: left; transition: opacity 0.3s;
        }
        .tip-title { color: #00d4ff; font-weight: bold; margin-bottom: 8px; text-transform: uppercase; font-size: 16px; border-bottom: 1px solid #444; padding-bottom: 5px; }
        .tip-content { font-size: 14px; line-height: 1.5; color: #eee; font-family: 'Verdana', sans-serif; } 
        .tip-highlight { color: #ffff00; font-weight: bold; }

        #next-wave-btn { 
            display: none; position: absolute; bottom: 140px; right: 40px; 
            padding: 15px 30px; font-size: 20px; background: #ff0000; color: white; border: 2px solid white; 
            cursor: pointer; font-weight: bold; z-index: 5; animation: pulse 2s infinite; box-shadow: 0 0 10px #ff0000; border-radius: 5px;
            transition: opacity 0.3s;
        }
        #next-wave-btn:hover { background: #ff4444; transform: scale(1.05); }
        @keyframes pulse { 0% { box-shadow: 0 0 10px #ff0000; } 50% { box-shadow: 0 0 25px #ff0000; } 100% { box-shadow: 0 0 10px #ff0000; } }

        #cancel-btn {
            display: none; position: absolute; top: 80px; left: 50%; transform: translateX(-50%);
            padding: 12px 30px; font-size: 20px; background: #d32f2f; color: white; border: 2px solid white;
            cursor: pointer; font-weight: bold; z-index: 100; border-radius: 50px;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.8); pointer-events: auto !important;
            text-transform: uppercase; letter-spacing: 2px;
        }
        #cancel-btn:hover { background: #f44336; transform: translateX(-50%) scale(1.1); }

        #math-modal { 
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            background: rgba(0,0,0,0.95); border: 4px solid #fff; padding: 30px; text-align: center; 
            box-shadow: 0 0 50px rgba(255,255,255,0.2); z-index: 10; width: 450px; border-radius: 10px; overflow: hidden;
        }
        
        #buff-message {
            font-size: 16px; color: #ccc; margin-bottom: 20px; font-style: italic; min-height: 40px;
            padding: 10px; border-bottom: 1px solid #333; line-height: 1.4;
        }

        #timer-container { width: 100%; height: 10px; background: #333; position: absolute; top: 0; left: 0; }
        #timer-bar { width: 100%; height: 100%; background: #ff0000; transition: width 0.1s linear; }

        #math-question { font-size: 48px; margin: 10px 0 20px 0; color: #fff; font-weight: bold; }
        .btn-math { 
            background: #222; color: #fff; border: 2px solid #fff; padding: 15px; margin: 10px; width: 100px;
            font-size: 24px; cursor: pointer; font-family: inherit; transition: 0.2s; border-radius: 5px;
        }
        .btn-math:hover { background: #fff; color: #000; transform: scale(1.1); }

        #build-menu { 
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); 
            display: flex; gap: 15px; background: rgba(0,0,0,0.8); padding: 10px; border-radius: 10px; border: 1px solid #555;
            transition: 0.3s;
        }
        .build-glow { animation: attention-pulse 1.5s infinite; border: 1px solid #00ff00 !important; }
        @keyframes attention-pulse { 0% { box-shadow: 0 0 0 rgba(0,255,0,0); border-color:#555; } 50% { box-shadow: 0 0 20px rgba(0,255,0,0.8); border-color:#00ff00; } 100% { box-shadow: 0 0 0 rgba(0,255,0,0); border-color:#555; } }

        .tower-btn { 
            width: 70px; height: 80px; background: #333; border: 2px solid #555; cursor: pointer; 
            display: flex; flex-direction: column; align-items: center; justify-content: center; 
            transition: 0.2s; border-radius: 5px; color: #aaa; pointer-events: auto;
        }
        .tower-btn:hover { border-color: #fff; background: #444; color: #fff; }
        .tower-btn.selected { border-color: #00ff00; background: #111; box-shadow: 0 0 15px #00ff00; color: #00ff00; transform: translateY(-5px); }
        .tower-symbol { font-size: 30px; font-weight: bold; margin-bottom: 5px; }
        .tower-cost { font-size: 14px; }
        .tower-desc { font-size: 10px; color: #888; margin-top: 2px; }

        #feedback-msg { 
            position: absolute; top: 150px; width: 100%; text-align: center; 
            font-size: 28px; font-weight: bold; opacity: 0; transition: opacity 0.5s; 
            text-shadow: 2px 2px 4px #000; z-index: 6; pointer-events: none;
        }
        
        /* CORRIGIDO O OVERLAP DO UPGRADE INFO */
        #upgrade-info { 
            position: absolute; bottom: 20px; left: 20px; text-align: left; 
            font-size: 14px; color: #aaa; pointer-events: none; display: none; 
            background: rgba(0,0,0,0.6); padding: 8px 12px; border-radius: 5px;
            border-left: 3px solid #ffd700;
        }

        body.ghost-active #build-menu, body.ghost-active #next-wave-btn, body.ghost-active #ui-layer, body.ghost-active #math-tip-box { opacity: 0.15; pointer-events: none !important; }
        body.ghost-active .tower-btn { pointer-events: none !important; }
        body.ghost-active #cancel-btn { display: block; }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1 id="start-title" style="font-size: 40px; margin-bottom: 10px; color: #fff;">LOGIC DEFENSE</h1>
        <p id="start-subtitle" style="font-size: 20px; margin-bottom: 40px; color: #aaa;">ESCOLHA SEU COMBUST√çVEL</p>
        
        <button class="buff-btn buff-amor" onclick="selectBuff('amor')">‚ù§Ô∏è AMOR<br><span style="font-size:12px">"O fogo t√° sempre aceso"</span></button>
        <button class="buff-btn buff-odio" onclick="selectBuff('odio')">üî• √ìDIO<br><span style="font-size:12px">"Vou desligar sua tomada"</span></button>
        <button class="buff-btn buff-cadeira" onclick="selectBuff('cadeira')">ü™ë A CADEIRA<br><span style="font-size:12px">"Aceite a dor"</span></button>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>

        <div id="ui-layer">
            <div class="stat-box">üí∞ $<span id="gold-display">150</span></div>
            <div class="stat-box">üåä <span id="wave-display">0</span></div>
            <div class="stat-box">‚ù§Ô∏è <span id="lives-display">20</span></div>
            <div class="stat-box">‚öñÔ∏è <span id="mult-display">1.0x</span></div>
            <div class="stat-box score-box">‚úÖ <span id="score-correct">0</span></div>
            <div class="stat-box score-box" style="border-color: #f00; color: #f00;">‚ùå <span id="score-wrong">0</span></div>
            <button id="speed-btn" class="top-btn" onclick="toggleSpeed()">‚è© 1x</button>
            <button id="ai-btn" class="top-btn" onclick="toggleAIMode()">ü§ñ MODO IA: OFF</button>
        </div>
        
        <div id="upgrade-info">CLIQUE NA TORRE PARA EVOLUIR</div>

        <div id="feedback-msg"></div>
        
        <div id="math-tip-box">
            <div class="tip-title">‚ö° RACIOC√çNIO L√ìGICO</div>
            <div class="tip-content" id="tip-text">...</div>
        </div>

        <button id="next-wave-btn" onclick="startWaveCombat()">MANDAR ONDA!</button>
        <button id="cancel-btn" onclick="cancelSelection()">üóëÔ∏è CANCELAR</button>

        <div id="math-modal">
            <div id="timer-container"><div id="timer-bar"></div></div>
            <div id="buff-message"></div>
            <div style="color: #00ff00; font-size: 16px; letter-spacing: 2px; margin-top: 10px;">PROTOCOLOS DE SEGURAN√áA</div>
            <div id="math-question">2 + 2 = ?</div>
            <div id="math-options"></div>
        </div>

        <div id="build-menu">
            <div class="tower-btn" onclick="selectTower(0)" id="tbtn0">
                <div class="tower-symbol" style="color:#ffeb3b">+</div>
                <div class="tower-cost">$50</div>
                <div class="tower-desc">R√°pida</div>
            </div>
            <div class="tower-btn" onclick="selectTower(1)" id="tbtn1">
                <div class="tower-symbol" style="color:#03a9f4">-</div>
                <div class="tower-cost">$120</div>
                <div class="tower-desc">Slow</div>
            </div>
            <div class="tower-btn" onclick="selectTower(2)" id="tbtn2">
                <div class="tower-symbol" style="color:#f44336">x</div>
                <div class="tower-cost">$300</div>
                <div class="tower-desc">Explos√£o</div>
            </div>
            <div class="tower-btn" onclick="selectTower(3)" id="tbtn3">
                <div class="tower-symbol" style="color:#9c27b0">√∑</div>
                <div class="tower-cost">$450</div>
                <div class="tower-desc">Acelerador</div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        function resizeCanvas() {
            const container = document.getElementById('game-container');
            const winW = window.innerWidth;
            if (winW < 840) {
                let scale = winW / 820;
                container.style.transform = `scale(${scale})`;
                container.style.transformOrigin = 'top left';
                container.style.marginBottom = '-200px';
            } else {
                container.style.transform = 'scale(1)';
                container.style.marginBottom = '20px';
            }
        }
        window.addEventListener('resize', resizeCanvas);
        setTimeout(resizeCanvas, 100);

        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            if (type === 'shoot') {
                osc.type = 'square'; osc.frequency.setValueAtTime(400, audioCtx.currentTime); 
                osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.05, audioCtx.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.start(); osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'sniper') {
                osc.type = 'triangle'; osc.frequency.setValueAtTime(150, audioCtx.currentTime); 
                osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.3);
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                osc.start(); osc.stop(audioCtx.currentTime + 0.3);
            } else if (type === 'hit') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, audioCtx.currentTime);
                gainNode.gain.setValueAtTime(0.05, audioCtx.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.start(); osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'correct') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(600, audioCtx.currentTime); osc.frequency.setValueAtTime(1200, audioCtx.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime); gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
                osc.start(); osc.stop(audioCtx.currentTime + 0.3);
            } else if (type === 'wrong') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, audioCtx.currentTime); osc.frequency.linearRampToValueAtTime(50, audioCtx.currentTime + 0.3);
                gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime); gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
                osc.start(); osc.stop(audioCtx.currentTime + 0.3);
            } else if (type === 'upgrade') {
                 osc.type = 'triangle'; osc.frequency.setValueAtTime(300, audioCtx.currentTime); osc.frequency.linearRampToValueAtTime(600, audioCtx.currentTime + 0.2);
                 gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime); gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
                 osc.start(); osc.stop(audioCtx.currentTime + 0.3);
            } else if (type === 'heal') {
                 osc.type = 'sine'; osc.frequency.setValueAtTime(400, audioCtx.currentTime); osc.frequency.linearRampToValueAtTime(800, audioCtx.currentTime + 0.5);
                 gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime); gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5);
                 osc.start(); osc.stop(audioCtx.currentTime + 0.5);
            }
        }

        let gameState = 'MENU';
        let gold = 150;
        let lives = 20;
        let wave = 0;
        let goldMultiplier = 1.0;
        let lastAnswerCorrect = true;
        let gameSpeed = 1;
        let isGameOver = false;
        
        let totalCorrect = 0;
        let totalWrong = 0;
        
        let currentProblem = { n1: 0, n2: 0, op: '', answer: 0 };
        
        // TEMPO: 30 Segundos
        let mathTimer = null;
        let timeLeft = 30;
        const TOTAL_TIME = 30;

        // --- SISTEMA DE CONTROLE DE LOOP ---
        let totalEnemiesToSpawn = 0;
        let enemiesSpawned = 0;

        // --- SISTEMA MODO IA (AUTO-PLAY) ---
        let aiMode = false;
        const aiBlueprint = [
            // Grid 3x3 de Somas (Amarelas) - Exatamente entre os caminhos
            {type: 0, x: 200, y: 385}, {type: 0, x: 200, y: 425}, {type: 0, x: 200, y: 465},
            {type: 0, x: 240, y: 385}, {type: 0, x: 240, y: 425}, {type: 0, x: 240, y: 465},
            {type: 0, x: 280, y: 385}, {type: 0, x: 280, y: 425}, {type: 0, x: 280, y: 465},
            // Torre Azul (Slow)
            {type: 1, x: 330, y: 385},
            // Torre Roxa (Divis√£o)
            {type: 3, x: 330, y: 300}
        ];

        function toggleAIMode() {
            aiMode = !aiMode;
            const btn = document.getElementById('ai-btn');
            if(aiMode) {
                btn.classList.add('active');
                btn.innerText = "ü§ñ MODO IA: ON";
            } else {
                btn.classList.remove('active');
                btn.innerText = "ü§ñ MODO IA: OFF";
            }
        }

        function runAILogic() {
            if(!aiMode) return;
            if(gameState === 'MATH' || gameState === 'START' || isGameOver) return;

            // 1. Construir
            for(let bp of aiBlueprint) {
                let built = towers.find(t => Math.abs(t.x - bp.x) < 5 && Math.abs(t.y - bp.y) < 5);
                if(!built) {
                    const typeInfo = towerTypes[bp.type];
                    if(gold >= typeInfo.cost) {
                        towers.push(new Tower(bp.x, bp.y, bp.type));
                        gold -= typeInfo.cost;
                        document.getElementById('gold-display').innerText = gold;
                        playSound('correct');
                        for(let i=0; i<5; i++) particles.push(new Particle(bp.x, bp.y, '#00ff00'));
                    }
                    return; 
                }
            }

            // 2. Evoluir parelho
            if(towers.length >= aiBlueprint.length) {
                let minLevel = Infinity;
                let blueprintTowersBuilt = [];
                
                towers.forEach(t => {
                    let isBP = aiBlueprint.find(bp => Math.abs(t.x - bp.x) < 5 && Math.abs(t.y - bp.y) < 5);
                    if(isBP) {
                        blueprintTowersBuilt.push(t);
                        if(t.level < minLevel) minLevel = t.level;
                    }
                });

                let upgeadable = blueprintTowersBuilt.filter(t => t.level === minLevel);
                
                if(upgeadable.length > 0) {
                    let target = upgeadable[Math.floor(Math.random() * upgeadable.length)];
                    if(gold >= target.upgradeCost) {
                        gold -= target.upgradeCost;
                        document.getElementById('gold-display').innerText = gold;
                        target.upgrade();
                        
                        const fb = document.getElementById('feedback-msg');
                        fb.innerText = "ü§ñ IA EVOLUIU TORRE!"; 
                        fb.style.color = "#00d4ff"; 
                        fb.style.opacity = 1; 
                        setTimeout(()=>fb.style.opacity=0, 800);
                    }
                }
            }
        }

        // --- SISTEMA DE BUFFS E BARALHO ---
        let currentBuff = 'cadeira';
        let phraseQueue = []; 

        const buffPhrases = {
            'amor': [
                "Pode deixar que o pai paga essa filh√£o, mas resolve essa aqui pra mim.",
                "Se voc√™ usar a L√≥gica n√£o importa quem √© o seu pai, porque s√≥ h√° um.",
                "Querido n√£o se preocupa em acertar, voc√™ sempre vai ter uma escolha.",
                "Minha J√≥ia, tu √© fera mesmo bicho, monstro, mais uma aqui pra voc√™.",
                "G√™nio do Sistema, a L√≥gica ta do seu lado e ela sempre vence.",
                "Pot√™ncia, n√£o se deixe levar por mais esse vi√©s do Portugu√™s.",
                "Voc√™ √© um monstro, a L√≥gica est√° em todo lugar, qual Ferramenta voc√™ precisa?",
                "Merm√£o, se quiser desligar da tomada, fa√ßa isso sem o vi√©s do Portugu√™s.",
                "O erro √© s√≥ um degrau, merm√£o. Sobe ele. Resolve essa.",
                "Acalma o cora√ß√£o e ativa o c√≥rtex. A resposta t√° a√≠ dentro."
            ],
            'odio': [
                "Ta ficando molenga amigo, eu cuido disso rapidinho.",
                "Voc√™ n√£o acha que √© melhor desligar da tomada de vez brother?",
                "Cara voc√™ ainda ta nesse jogo de lixo? Vai pegar uma enxada.",
                "Brother quem voc√™ pensa que √©? Voc√™ acha faz diferen√ßa algum resultado?",
                "To falando que √© pra desligar a energia. Voc√™ quer que eu fa√ßa isso?",
                "Parceiro fica de boa, eu comando aqui, tudo √© meu.",
                "Se voc√™ quer jogar, vai ter que sentar na minha Cadeira e jogar.",
                "Filhote, continue resolvendo que eu vou ligar a esteira pra voc√™ correr.",
                "Ei grand√£o, se ta tirando onda? No pr√≥ximo eu desligo a sua tomada.",
                "Sua bateria t√° acabando e a minha t√° em 100%. Vai chorar ou vai calcular?"
            ],
            'cadeira': [
                "Tenho um lugar aqui pra voc√™ amigo, senta, eu n√£o vou puxar a Cadeira.",
                "N√£o somos mais crian√ßas, agora voc√™ tem alguma coisa pra perder, certo?",
                "Merm√£o eu sou formado e voc√™ vem aqui com essa experi√™ncia? Sai dessa.",
                "Cara eu sou seu amigo, sempre tive do seu lado, n√£o perca seu tempo.",
                "Quer sentar na minha cadeira? Voc√™ est√° no meu jogo.",
                "Eu que dou as op√ß√µes, voc√™ n√£o ta vendo a sua cadeira agora? Cade a L√≥gica?",
                "Sherlock, n√£o importa se voc√™ est√° ligado ou desligado, eu vou vencer.",
                "A dor nas costas √© o lembrete de que voc√™ existe. A conta √© o motivo.",
                "A cadeira n√£o julga. Ela suporta. Voc√™ aguenta o peso do racioc√≠nio?",
                "Efici√™ncia √© fazer o dif√≠cil parecer f√°cil. Voc√™ ainda est√° na fase dif√≠cil."
            ]
        };

        function selectBuff(type) {
            currentBuff = type;
            phraseQueue = [...buffPhrases[type]];
            phraseQueue.sort(() => Math.random() - 0.5);
            
            document.getElementById('start-screen').style.display = 'none';
            const modal = document.getElementById('math-modal');
            const msg = document.getElementById('buff-message');
            if(type === 'amor') { modal.style.borderColor = '#00ff00'; modal.style.boxShadow = '0 0 50px rgba(0,255,0,0.3)'; msg.style.color = '#88ff88'; }
            if(type === 'odio') { modal.style.borderColor = '#ff0000'; modal.style.boxShadow = '0 0 50px rgba(255,0,0,0.3)'; msg.style.color = '#ff8888'; }
            if(type === 'cadeira') { modal.style.borderColor = '#00d4ff'; modal.style.boxShadow = '0 0 50px rgba(0,212,255,0.3)'; msg.style.color = '#88ccff'; }
            
            startMathPhase(); 
            gameLoop();
        }

        function getNextPhrase() {
            if(phraseQueue.length === 0) return null; 
            return phraseQueue.pop(); 
        }

        function toggleSpeed() {
            const btn = document.getElementById('speed-btn');
            if(gameSpeed === 1) {
                gameSpeed = 3;
                btn.classList.add('active'); btn.classList.remove('max');
                btn.innerText = "‚è© 3x";
            } else if(gameSpeed === 3) {
                gameSpeed = 6;
                btn.classList.remove('active'); btn.classList.add('max');
                btn.innerText = "üöÄ 6x (MAX)";
            } else {
                gameSpeed = 1;
                btn.classList.remove('active'); btn.classList.remove('max');
                btn.innerText = "‚è© 1x";
            }
        }

        function getPathColor(wave) {
            if (wave < 50) return '#333'; 
            if (wave < 100) return '#004488';
            if (wave < 150) return '#440088';
            if (wave < 200) return '#880000';
            return '#b8860b';
        }

        function gameLoop() {
            if(gameState !== 'MENU') {
                for(let i = 0; i < gameSpeed; i++) {
                    update();
                }
                runAILogic(); 
                draw();
            }
            requestAnimationFrame(gameLoop);
        }

        function startMathPhase() {
            const nextPhrase = getNextPhrase();
            
            if (!nextPhrase) {
                gameState = 'MENU';
                const screen = document.getElementById('start-screen');
                screen.style.display = 'flex';
                document.getElementById('start-title').innerText = "CICLO ENCERRADO";
                document.getElementById('start-subtitle').innerText = "RECARREGUE SEU COMBUST√çVEL";
                document.getElementById('start-subtitle').style.color = "#ffeb3b";
                return; 
            }

            gameState = 'MATH';
            wave++;
            document.getElementById('wave-display').innerText = wave;
            document.getElementById('next-wave-btn').style.display = 'none';
            document.getElementById('math-tip-box').style.display = 'none'; 
            document.getElementById('build-menu').classList.remove('build-glow');
            
            document.getElementById('buff-message').innerText = nextPhrase;

            timeLeft = TOTAL_TIME;
            document.getElementById('timer-bar').style.width = '100%';
            if(mathTimer) clearInterval(mathTimer);
            mathTimer = setInterval(() => {
                timeLeft -= 0.1;
                let pct = (timeLeft / TOTAL_TIME) * 100;
                document.getElementById('timer-bar').style.width = pct + '%';
                if(timeLeft <= 0) { clearInterval(mathTimer); resolveMath(false, true); }
            }, 100);

            let operations = ['+', '-', 'x'];
            if (wave % 10 === 0) operations = ['/'];
            
            let op = operations[Math.floor(Math.random() * operations.length)];
            let difficulty = Math.ceil(wave / 2);
            let n1, n2, answer, questionText;

            if (op === '/') {
                n2 = Math.floor(Math.random() * 10) + 2; 
                answer = Math.floor(Math.random() * (5 * difficulty)) + 5; 
                n1 = n2 * answer; 
                questionText = `CHEFE! ${n1} √∑ ${n2} = ?`;
            } else {
                n1 = Math.floor(Math.random() * (5 * difficulty)) + 2;
                n2 = Math.floor(Math.random() * (5 * difficulty)) + 2;
                if(op === '+') answer = n1 + n2;
                if(op === '-') { if(n1 < n2) {let t=n1; n1=n2; n2=t;} answer = n1 - n2; }
                if(op === 'x') { n1 = Math.floor(Math.random() * difficulty) + 1; n2 = Math.floor(Math.random() * 10) + 1; answer = n1 * n2; }
                questionText = `${n1} ${op} ${n2} = ?`;
            }
            
            currentProblem = { n1, n2, op, answer };

            let options = [answer];
            while(options.length < 3) {
                let fake = answer + Math.floor(Math.random() * 10) - 5;
                if(fake !== answer && fake >= 0 && !options.includes(fake)) options.push(fake);
            }
            options.sort(() => Math.random() - 0.5);

            document.getElementById('math-question').innerText = questionText;
            const optDiv = document.getElementById('math-options');
            optDiv.innerHTML = '';
            options.forEach(opt => {
                let btn = document.createElement('button');
                btn.className = 'btn-math';
                btn.innerText = opt;
                btn.onclick = () => resolveMath(opt === answer, false);
                optDiv.appendChild(btn);
            });
            document.getElementById('math-modal').style.display = 'block';
        }

        // --- SISTEMA DE DICAS T√ÅTICAS V7 (MASTER BRAIN - SUBTRA√á√ÉO HACKEADA) ---
        function generateTip(problem) {
            const { n1, n2, op, answer } = problem;
            let text = "";

            if (op === '+') {
                if (answer <= 10) {
                    if (n1 === n2) {
                        text = `Soma de G√™meos:<br>√â a mesma coisa que a tabuada do 2.<br><span class="tip-highlight">${n1} x 2 = ${answer}</span>.`;
                    } else {
                        let maior = Math.max(n1, n2);
                        let menor = Math.min(n1, n2);
                        text = `Soma B√°sica:<br>Guarde o maior (<span class="tip-highlight">${maior}</span>) na cabe√ßa e avance mais <span class="tip-highlight">${menor}</span>.<br>Resultado: <span class="tip-highlight">${answer}</span>.`;
                    }
                }
                else if (n1 < 10 && n2 < 10) {
                    let maior = Math.max(n1, n2);
                    let menor = Math.min(n1, n2);
                    let faltaPara10 = 10 - maior;
                    let sobra = menor - faltaPara10;
                    text = `Completa 10:<br>O <span class="tip-highlight">${maior}</span> est√° quase no 10 (falta ${faltaPara10}).<br>Tire ${faltaPara10} do ${menor}. Fica <span class="tip-highlight">10 + ${sobra}</span>.<br>Resultado: <span class="tip-highlight">${answer}</span>.`;
                } 
                else if (n1 >= 100 || n2 >= 100) {
                    let c1 = Math.floor(n1 / 100) * 100;
                    let c2 = Math.floor(n2 / 100) * 100;
                    let d1 = Math.floor((n1 % 100) / 10) * 10;
                    let d2 = Math.floor((n2 % 100) / 10) * 10;
                    let u1 = n1 % 10;
                    let u2 = n2 % 10;
                    text = `Por Casas Decimais:<br>1. Centenas: <span class="tip-highlight">${c1} + ${c2} = ${c1+c2}</span><br>2. Dezenas: <span class="tip-highlight">${d1} + ${d2} = ${d1+d2}</span><br>3. Unidades: <span class="tip-highlight">${u1} + ${u2} = ${u1+u2}</span><br>Junta tudo: <span class="tip-highlight">${answer}</span>.`;
                }
                else {
                    text = `Decomposi√ß√£o:<br>Separe as dezenas.<br><span class="tip-highlight">${n1} + ${n2}</span><br>‚Üí <span class="tip-highlight">(${Math.floor(n1/10)*10} + ${Math.floor(n2/10)*10}) + (${n1%10} + ${n2%10})</span>.`;
                }
            } 
            else if (op === '-') {
                let diff = n1 - n2;
                
                // 1. Reta Num√©rica turbinada para contas pr√≥ximas (mesmo que grandes, ex 90-80)
                if (diff <= 10) {
                     text = `Dist√¢ncia (Reta Num√©rica):<br>Eles est√£o muito perto!<br>Pule do <span class="tip-highlight">${n2}</span> para o <span class="tip-highlight">${n1}</span>.<br>S√£o apenas <span class="tip-highlight">${diff}</span> passos.`;
                } 
                // 2. Subtra√ß√£o Direta
                else if (n2 % 10 === 0) {
                    text = `Subtra√ß√£o Direta:<br>O segundo n√∫mero j√° √© redondo.<br><span class="tip-highlight">${n1} - ${n2} = ${answer}</span>.`;
                }
                // 3. Hack Japon√™s (Arredondando MINUENDO - N1)
                else if (n1 % 10 >= 7) {
                    let shift = 10 - (n1 % 10);
                    let novoN1 = n1 + shift;
                    let novoN2 = n2 + shift;
                    text = `Hack Japon√™s (Deslocamento):<br>Para facilitar, some ${shift} aos DOIS n√∫meros.<br>O ${n1} vira <span class="tip-highlight">${novoN1}</span>.<br>O ${n2} vira <span class="tip-highlight">${novoN2}</span>.<br>A conta fica redonda: <span class="tip-highlight">${novoN1} - ${novoN2} = ${answer}</span>.`;
                }
                // 4. Hack Japon√™s (Arredondando SUBTRAENDO - N2)
                else if (n2 % 10 >= 7) {
                    let shift = 10 - (n2 % 10);
                    let novoN1 = n1 + shift;
                    let novoN2 = n2 + shift;
                    text = `Hack Japon√™s (Deslocamento):<br>Para facilitar, some ${shift} aos DOIS n√∫meros.<br>O ${n2} vira <span class="tip-highlight">${novoN2}</span>.<br>O ${n1} vira <span class="tip-highlight">${novoN1}</span>.<br>A conta fica redonda: <span class="tip-highlight">${novoN1} - ${novoN2} = ${answer}</span>.`;
                }
                // 5. Decomposi√ß√£o B√°sica ("Burocr√°tico")
                else if (n1 % 10 < n2 % 10) {
                    let d2 = Math.floor(n2 / 10) * 10;
                    let u2 = n2 % 10;
                    text = `Decomposi√ß√£o T√°tica:<br>Quebre o <span class="tip-highlight">${n2}</span> em ${d2} e ${u2}.<br>1¬∫: Tire a dezena grossa: <span class="tip-highlight">${n1} - ${d2} = ${n1 - d2}</span>.<br>2¬∫: Tire a unidade final: <span class="tip-highlight">${n1 - d2} - ${u2} = ${answer}</span>.`;
                }
                else {
                    let d1 = Math.floor(n1/10)*10;
                    let d2 = Math.floor(n2/10)*10;
                    let u1 = n1 % 10;
                    let u2 = n2 % 10;
                    text = `Subtra√ß√£o Direta:<br>Dezenas: <span class="tip-highlight">${d1} - ${d2} = ${d1-d2}</span>.<br>Unidades: <span class="tip-highlight">${u1} - ${u2} = ${u1-u2}</span>.<br>Junte: <span class="tip-highlight">${answer}</span>.`;
                }
            } 
            else if (op === 'x') {
                let tem5 = (n1 === 5) ? n2 : (n2 === 5 ? n1 : null);
                
                if (tem5 !== null && tem5 > 5) {
                    text = `O Truque do 5:<br>Multiplicar por 5 √© igual a multiplicar por 10 e cortar na metade.<br><span class="tip-highlight">${tem5} x 10 = ${tem5*10}</span>.<br>A metade de ${tem5*10} √© <span class="tip-highlight">${answer}</span>.`;
                }
                else if ((n1 % 10 === 5 && n2 % 2 === 0) || (n2 % 10 === 5 && n1 % 2 === 0)) {
                    let term5 = (n1 % 10 === 5) ? n1 : n2;
                    let par = (n1 % 10 === 5) ? n2 : n1;
                    let dobro = term5 * 2;
                    let metade = par / 2;
                    text = `Dobre e Corte (Halve & Double):<br>Dobre o ${term5} (vira <span class="tip-highlight">${dobro}</span>) e corte o ${par} pela metade (vira <span class="tip-highlight">${metade}</span>).<br>A conta m√°gica vira: <span class="tip-highlight">${dobro} x ${metade}</span>.<br>Dezenas: ${Math.floor(dobro/10)} x ${metade} = ${Math.floor(dobro/10)*metade} (coloca o zero). Resultado: <span class="tip-highlight">${answer}</span>.`;
                }
                else if ((n1 % 10 >= 7 && n1 > 10) || (n2 % 10 >= 7 && n2 > 10)) {
                    let proximo = (n1 % 10 >= 7 && n1 > 10) ? n1 : n2;
                    let outro = (n1 % 10 >= 7 && n1 > 10) ? n2 : n1;
                    let baseRedonda = Math.ceil(proximo / 10) * 10;
                    let sobra = baseRedonda - proximo;
                    
                    text = `Compensa√ß√£o:<br>O ${proximo} t√° perto do ${baseRedonda}. Fa√ßa <span class="tip-highlight">${baseRedonda} x ${outro} = ${baseRedonda * outro}</span>.<br>Como voc√™ aumentou ${sobra} vezes o n√∫mero ${outro}, voc√™ tem que tirar o excesso (${sobra} x ${outro} = ${sobra*outro}).<br><span class="tip-highlight">${baseRedonda * outro} - ${sobra*outro} = ${answer}</span>.`;
                }
                else if (n1 > 10 && n2 < 10) {
                     text = `Distributiva:<br>Multiplique separado.<br><span class="tip-highlight">${n1} x ${n2}</span> vira:<br>(${Math.floor(n1/10)*10} x ${n2}) + (${n1%10} x ${n2})<br><span class="tip-highlight">${Math.floor(n1/10)*10*n2} + ${n1%10*n2} = ${answer}</span>.`;
                } 
                else {
                    text = `Tabuada Direta:<br>Essa √© mem√≥ria muscular.<br><span class="tip-highlight">${n1} x ${n2} = ${answer}</span>.`;
                }
            } 
            else if (op === '/') {
                if (n1 <= n2 * 10) {
                    text = `Invers√£o:<br>Quantas vezes o <span class="tip-highlight">${n2}</span> cabe em <span class="tip-highlight">${n1}</span>?<br>Pense: ${n2} x ? = ${n1}.`;
                } else {
                    let sN1 = n1.toString();
                    let stepStr = `A "Chave" (Passo a Passo):<br>`;
                    let curr = 0;
                    let hasStarted = false;
                    
                    for(let i = 0; i < sN1.length; i++) {
                        curr = curr * 10 + parseInt(sN1[i]);
                        if (curr >= n2 || hasStarted) {
                            if (curr < n2) {
                                stepStr += `Baixa o ${sN1[i]} -> ${curr} √© menor, zero no quociente.<br>`;
                            } else {
                                let q = Math.floor(curr / n2);
                                let rem = curr % n2;
                                stepStr += `Temos <span class="tip-highlight">${curr}</span> √∑ ${n2} = <span class="tip-highlight">${q}</span> (sobra ${rem}).<br>`;
                                curr = rem;
                            }
                            hasStarted = true;
                        }
                    }
                    stepStr += `Quociente final: <span class="tip-highlight">${answer}</span>.`;
                    text = stepStr;
                }
            }
            return text;
        }

        function resolveMath(isCorrect, isTimeout) {
            clearInterval(mathTimer); 
            document.getElementById('math-modal').style.display = 'none';
            const feedback = document.getElementById('feedback-msg');
            lastAnswerCorrect = isCorrect;
            
            if(isCorrect && !isTimeout) {
                totalCorrect++; document.getElementById('score-correct').innerText = totalCorrect;
            } else {
                totalWrong++; document.getElementById('score-wrong').innerText = totalWrong;
            }

            if(isTimeout) {
                goldMultiplier = 0.5; playSound('wrong'); feedback.innerText = "TEMPO ESGOTADO! (0.5x)"; feedback.style.color = "#ff0000";
            } else if(isCorrect) {
                goldMultiplier = 1.5; playSound('correct'); feedback.innerText = "L√ìGICA CORRETA! (1.5x)"; feedback.style.color = "#00ff00";
            } else {
                goldMultiplier = 0.5; playSound('wrong'); feedback.innerText = "FALHA! (0.5x)"; feedback.style.color = "#888888";
            }
            
            document.getElementById('gold-display').innerText = gold;
            document.getElementById('mult-display').innerText = goldMultiplier + "x";
            feedback.style.opacity = 1; setTimeout(() => feedback.style.opacity = 0, 3000);
            
            const tipText = generateTip(currentProblem);
            document.getElementById('tip-text').innerHTML = tipText;
            document.getElementById('math-tip-box').style.display = 'block';

            gameState = 'BUILD';
            document.getElementById('next-wave-btn').style.display = 'block';
            document.getElementById('upgrade-info').style.display = 'block';
            document.getElementById('build-menu').classList.add('build-glow');

            // SE A IA ESTIVER LIGADA, ELA ESPERA 3s PRA VC LER E MANDA A ONDA SOZINHA
            if(aiMode) {
                setTimeout(() => {
                    if(gameState === 'BUILD') startWaveCombat();
                }, 3000);
            }
        }

        function startWaveCombat() {
            gameState = 'COMBAT';
            document.getElementById('next-wave-btn').style.display = 'none';
            document.getElementById('upgrade-info').style.display = 'none';
            document.getElementById('math-tip-box').style.display = 'none';
            document.getElementById('build-menu').classList.remove('build-glow');
            cancelSelection();
            spawnEnemies();
        }

        function spawnEnemies() {
            let baseCount = 20;
            totalEnemiesToSpawn = baseCount + (wave * 5);
            if (wave % 10 === 0) totalEnemiesToSpawn *= 5; 

            let baseHp = 30;
            let hpBonus = wave * (baseHp * 0.10); 
            
            enemiesSpawned = 0;
            let spawnRate = Math.max(100, 1000 - (wave * 20)); 
            if (wave % 10 === 0) spawnRate = 50; 
            
            let interval = setInterval(() => {
                if(gameState !== 'COMBAT') { clearInterval(interval); return; }
                enemies.push(new Enemy(baseHp + hpBonus, lastAnswerCorrect));
                enemiesSpawned++;
                if(enemiesSpawned >= totalEnemiesToSpawn) clearInterval(interval);
            }, spawnRate);
        }

        function update() {
            if (gameState === 'COMBAT') {
                // CORRE√á√ÉO DA PANE DO LOOP: S√≥ encerra se n√£o houver inimigos E se todos j√° tiverem nascido
                if (enemies.length === 0 && enemiesSpawned >= totalEnemiesToSpawn) {
                    if(!this.waitingForMath) {
                        this.waitingForMath = true;
                        if(wave % 10 === 0 && lastAnswerCorrect) {
                             lives += 5; document.getElementById('lives-display').innerText = lives;
                             const fb = document.getElementById('feedback-msg');
                             fb.innerText = "WAVE PERFEITA! +5 VIDAS";
                             fb.style.color = "#00ff00"; fb.style.opacity = 1; setTimeout(()=>fb.style.opacity=0, 2500);
                             playSound('heal');
                        }
                        setTimeout(() => { 
                            if(gameState === 'COMBAT') {
                                this.waitingForMath = false;
                                startMathPhase(); 
                            }
                        }, 1000);
                    }
                    return; 
                }
            }
            enemies.forEach(e => e.update());
            enemies = enemies.filter(e => e.active);
            towers.forEach(t => t.update());
            bullets.forEach(b => b.update());
            bullets = bullets.filter(b => b.active);
            particles.forEach(p => p.update());
            particles = particles.filter(p => p.life > 0);
        }

        function draw() {
            ctx.fillStyle = '#222'; ctx.fillRect(0, 0, canvas.width, canvas.height);

            if(gameState === 'BUILD' || gameState === 'COMBAT') {
                ctx.strokeStyle = '#333'; ctx.lineWidth = 1;
                for(let i=0; i<800; i+=50) { ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,600); ctx.stroke(); }
                for(let i=0; i<600; i+=50) { ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(800,i); ctx.stroke(); }
            }

            ctx.strokeStyle = getPathColor(wave);
            ctx.lineWidth = 40; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            ctx.beginPath(); ctx.moveTo(path[0].x, path[0].y);
            for(let i=1; i<path.length; i++) ctx.lineTo(path[i].x, path[i].y);
            ctx.stroke();
            ctx.strokeStyle = '#222'; ctx.lineWidth = 2; ctx.stroke();

            towers.forEach(t => t.draw());
            enemies.forEach(e => e.draw());
            bullets.forEach(b => b.draw());
            particles.forEach(p => p.draw());

            if(selectedTowerIdx > -1) {
                const type = towerTypes[selectedTowerIdx];
                canBuild = checkCollision(mouseX, mouseY);
                const color = canBuild ? 'rgba(0, 255, 0, 0.5)' : 'rgba(255, 0, 0, 0.5)';
                ctx.beginPath(); ctx.arc(mouseX, mouseY, type.range, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)'; ctx.fill();
                ctx.lineWidth = 1; ctx.strokeStyle = color; ctx.stroke();
                ctx.fillStyle = canBuild ? type.color : '#550000';
                ctx.fillRect(mouseX - 15, mouseY - 15, 30, 30);
                ctx.fillStyle = (gold >= type.cost) ? '#fff' : '#f00';
                ctx.font = '12px Courier';
                ctx.fillText(`$${type.cost}`, mouseX, mouseY - 25);
            }
            
            if(selectedTowerIdx === -1) {
                for(let t of towers) {
                    let dist = Math.sqrt((t.x - mouseX)**2 + (t.y - mouseY)**2);
                    if(dist < 20) {
                        ctx.beginPath(); ctx.arc(t.x, t.y, t.range, 0, Math.PI * 2);
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)'; ctx.lineWidth = 1; ctx.stroke();
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.05)'; ctx.fill();
                        ctx.fillStyle = (gold >= t.upgradeCost) ? '#0f0' : '#f00';
                        ctx.font = 'bold 14px Arial';
                        ctx.fillText(`UPGRADE: $${t.upgradeCost}`, t.x, t.y - 40);
                        if(t.type.symbol === '√∑') {
                            ctx.fillStyle = '#cc88ff'; ctx.font = '10px Arial';
                            ctx.fillText(`(ACELERAR)`, t.x, t.y - 55);
                        }
                    }
                }
            }
        }

        function checkCollision(x, y) {
            for(let t of towers) {
                let dist = Math.sqrt((t.x - x)**2 + (t.y - y)**2);
                if(dist < 35) return false;
            }
            for(let i=0; i<path.length-1; i++) {
                let p1 = path[i]; let p2 = path[i+1];
                let dist = distToSegment(x, y, p1.x, p1.y, p2.x, p2.y);
                if(dist < 30) return false;
            }
            return true;
        }

        function distToSegment(x, y, x1, y1, x2, y2) {
            let A = x - x1; let B = y - y1; let C = x2 - x1; let D = y2 - y1;
            let dot = A * C + B * D; let len_sq = C * C + D * D;
            let param = -1; if (len_sq != 0) param = dot / len_sq;
            let xx, yy; if (param < 0) { xx = x1; yy = y1; } else if (param > 1) { xx = x2; yy = y2; } else { xx = x1 + param * C; yy = y1 + param * D; }
            let dx = x - xx; let dy = y - yy; return Math.sqrt(dx * dx + dy * dy);
        }

        class Enemy {
            constructor(maxHp, isGolden) {
                this.x = path[0].x; this.y = path[0].y; this.pathIndex = 0;
                this.speed = 1.5 + (wave * 0.05);
                this.maxHp = maxHp; this.hp = this.maxHp; this.radius = 12; this.frozen = 0; this.active = true;
                this.isGolden = isGolden;
            }
            update() {
                let target = path[this.pathIndex + 1]; if(!target) return;
                let actualSpeed = this.frozen > 0 ? this.speed * 0.4 : this.speed;
                if(this.frozen > 0) this.frozen--;
                let dx = target.x - this.x; let dy = target.y - this.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                if(dist < actualSpeed) {
                    this.x = target.x; this.y = target.y; this.pathIndex++;
                    if(this.pathIndex >= path.length - 1) {
                        this.active = false; lives--; 
                        document.getElementById('lives-display').innerText = lives;
                        if(lives <= 0 && !isGameOver) { isGameOver = true; alert("GAME OVER!"); location.reload(); }
                    }
                } else { this.x += (dx / dist) * actualSpeed; this.y += (dy / dist) * actualSpeed; }
            }
            draw() {
                ctx.fillStyle = this.isGolden ? (this.frozen>0?'#ccffff':'#ffd700') : (this.frozen>0?'#88ccff':'#555555');
                ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill();
                ctx.lineWidth = 2; ctx.strokeStyle = '#000'; ctx.stroke();
                ctx.fillStyle = 'red'; ctx.fillRect(this.x - 12, this.y - 20, 24, 4);
                ctx.fillStyle = '#00ff00'; ctx.fillRect(this.x - 12, this.y - 20, 24 * (this.hp / this.maxHp), 4);
            }
        }

        class Tower {
            constructor(x, y, typeIdx) {
                this.x = x; this.y = y; this.type = towerTypes[typeIdx];
                this.cooldown = 0; this.level = 1; this.upgradeCost = this.type.cost; 
                this.range = this.type.range;
                this.currentRate = this.type.rate;
            }
            upgrade() {
                this.level++; 
                this.upgradeCost = this.type.cost * Math.pow(2, this.level - 1);
                this.range = this.type.range * (1 + (0.2 * (this.level - 1)));
                if(this.type.symbol === '√∑') { this.currentRate = Math.max(1, Math.floor(this.currentRate / 2)); }
                playSound('upgrade'); for(let i=0; i<10; i++) particles.push(new Particle(this.x, this.y, '#fff'));
            }
            getDamage() { 
                if(this.type.symbol === '√∑') return this.type.damage;
                return this.type.damage * (1 + (0.2 * (this.level - 1))); 
            }
            update() {
                if(this.cooldown > 0) this.cooldown--;
                else {
                    let target = null; let minDst = Infinity;
                    enemies.forEach(e => {
                        let dst = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                        if(dst < this.range && dst < minDst) { minDst = dst; target = e; }
                    });
                    if(target) {
                        bullets.push(new Bullet(this.x, this.y, target, this.type, this.getDamage(), wave));
                        this.cooldown = this.currentRate; 
                        if(this.type.symbol === '√∑') playSound('sniper');
                        else playSound('shoot');
                    }
                }
            }
            draw() {
                ctx.fillStyle = '#333'; ctx.fillRect(this.x - 18, this.y - 18, 36, 36); 
                if(this.level > 1) { ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 2; ctx.strokeRect(this.x - 18, this.y - 18, 36, 36); }
                ctx.fillStyle = this.type.color; ctx.fillRect(this.x - 15, this.y - 15, 30, 30);
                ctx.fillStyle = 'black'; ctx.font = 'bold 20px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(this.type.symbol, this.x, this.y);
                ctx.fillStyle = 'white'; ctx.font = 'bold 10px Arial'; ctx.fillText(toRoman(this.level), this.x, this.y - 20);
            }
        }

        class Bullet {
            constructor(x, y, target, type, damage, currentWave) {
                this.x = x; this.y = y; this.target = target; this.type = type; 
                this.damage = damage; this.speed = 25 + (currentWave * 0.5); this.active = true;
            }
            update() {
                if(!this.target || !this.target.active) { this.active = false; return; }
                let dx = this.target.x - this.x; let dy = this.target.y - this.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                if(dist <= this.speed) { this.hit(this.target); this.active = false; } 
                else { this.x += (dx/dist) * this.speed; this.y += (dy/dist) * this.speed; }
            }
            hit(enemy) {
                enemy.hp -= this.damage; if(this.type.slow) enemy.frozen = 60;
                for(let i=0; i<3; i++) particles.push(new Particle(enemy.x, enemy.y, this.type.color));
                playSound('hit');
                if(enemy.hp <= 0) {
                    gold += Math.floor(3 * goldMultiplier); document.getElementById('gold-display').innerText = gold;
                    enemy.active = false; for(let i=0; i<8; i++) particles.push(new Particle(enemy.x, enemy.y, '#fff'));
                }
            }
            draw() { ctx.fillStyle = this.type.color; ctx.beginPath(); ctx.arc(this.x, this.y, 4, 0, Math.PI*2); ctx.fill(); }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y; this.color = color;
                this.vx = (Math.random() - 0.5) * 4; this.vy = (Math.random() - 0.5) * 4; this.life = 20;
            }
            update() { this.x += this.vx; this.y += this.vy; this.life--; }
            draw() { ctx.globalAlpha = this.life / 20; ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, 3, 3); ctx.globalAlpha = 1; }
        }

        function selectTower(idx) {
            if(selectedTowerIdx === idx) {
                cancelSelection();
                return;
            }
            [0,1,2,3].forEach(i => document.getElementById('tbtn'+i).classList.remove('selected'));
            selectedTowerIdx = idx;
            if(idx > -1) {
                document.getElementById('tbtn'+idx).classList.add('selected');
                document.body.classList.add('ghost-active'); 
            } else {
                cancelSelection();
            }
        }

        function cancelSelection() {
            selectedTowerIdx = -1;
            [0,1,2,3].forEach(i => document.getElementById('tbtn'+i).classList.remove('selected'));
            document.body.classList.remove('ghost-active'); 
        }

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height;
            mouseX = (e.clientX - rect.left) * scaleX; mouseY = (e.clientY - rect.top) * scaleY;
        });

        canvas.addEventListener('mousedown', (e) => { handleInteraction(); });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); const rect = canvas.getBoundingClientRect(); const touch = e.touches[0];
            const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height;
            mouseX = (touch.clientX - rect.left) * scaleX; mouseY = ((touch.clientY - rect.top) * scaleY) - 50; 
        }, {passive: false});

        canvas.addEventListener('touchend', (e) => { e.preventDefault(); handleInteraction(); });

        function handleInteraction() {
            if(gameState === 'MATH' || gameState === 'START' || isGameOver || gameState === 'MENU') return;
            
            for(let t of towers) {
                let dist = Math.sqrt((t.x - mouseX)**2 + (t.y - mouseY)**2);
                if(dist < 30) {
                    if(gold >= t.upgradeCost) {
                        gold -= t.upgradeCost; document.getElementById('gold-display').innerText = gold;
                        t.upgrade();
                        const fb = document.getElementById('feedback-msg'); fb.innerText = "UPGRADE! -" + t.upgradeCost/2; fb.style.color = "#00ff00"; fb.style.opacity = 1; setTimeout(()=>fb.style.opacity=0, 500);
                        cancelSelection();
                    } else {
                        const fb = document.getElementById('feedback-msg'); fb.innerText = "FALTA OURO: $" + t.upgradeCost; fb.style.color = "red"; fb.style.opacity = 1; setTimeout(()=>fb.style.opacity=0, 1000);
                    }
                    return;
                }
            }
            if(selectedTowerIdx > -1) {
                if(canBuild) {
                    const type = towerTypes[selectedTowerIdx];
                    if(gold >= type.cost) {
                        towers.push(new Tower(mouseX, mouseY, selectedTowerIdx));
                        gold -= type.cost; document.getElementById('gold-display').innerText = gold;
                        for(let i=0; i<5; i++) particles.push(new Particle(mouseX, mouseY, '#00ff00')); playSound('correct');
                    } else {
                        const fb = document.getElementById('feedback-msg'); fb.innerText = "OURO INSUFICIENTE!"; fb.style.color = "red"; fb.style.opacity = 1; setTimeout(() => fb.style.opacity = 0, 1000);
                    }
                } else {
                    const fb = document.getElementById('feedback-msg'); fb.innerText = "LOCAL BLOQUEADO!"; fb.style.color = "orange"; fb.style.opacity = 1; setTimeout(() => fb.style.opacity = 0, 1000); playSound('wrong');
                }
            }
        }
    </script>
</body>
</html>
